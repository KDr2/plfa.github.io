<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Quantifiers</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon" aria-hidden="true"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book" aria-hidden="true"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Negation/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Quantifiers.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Decidable/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header"><h1 class="post-title">Quantifiers: Universals and existentials</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-99" class="Keyword">module</a> <a id="plfa_plfa-part1-Quantifiers-106" href="../Quantifiers/#" class="Module">plfa.part1.Quantifiers</a> <a id="plfa_plfa-part1-Quantifiers-129" class="Keyword">where</a>
</pre><p>This chapter introduces universal and existential quantification.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-227" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-234" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Quantifiers-272" class="Symbol">as</a> <a id="plfa_plfa-part1-Quantifiers-275" class="Module">Eq</a>
<a id="plfa_plfa-part1-Quantifiers-278" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-283" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Quantifiers-286" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-292" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-293" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Quantifiers-296" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-298" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Quantifiers-302" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-304" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-309" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-316" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Quantifiers-325" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-331" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-332" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-333" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-335" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Quantifiers-339" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-341" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Quantifiers-344" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-346" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Quantifiers-349" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-351" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Quantifiers-354" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-356" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-361" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-368" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Quantifiers-385" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-391" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-392" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#665" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Quantifiers-394" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-396" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-401" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-408" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Quantifiers-421" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-427" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-428" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Quantifiers-431" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-433" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Sigma.html#234" class="Field">proj₁</a><a id="plfa_plfa-part1-Quantifiers-438" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-440" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Sigma.html#246" class="Field">proj₂</a><a id="plfa_plfa-part1-Quantifiers-445" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-447" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Quantifiers-456" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-457" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Quantifiers-461" class="Symbol">to</a> <a id="plfa_plfa-part1-Quantifiers-464" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Quantifiers-469" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-471" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-476" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-483" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Sum.html" class="Module">Data.Sum</a> <a id="plfa_plfa-part1-Quantifiers-492" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-498" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-499" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Sum.Base.html#743" class="Datatype Operator">_⊎_</a><a id="plfa_plfa-part1-Quantifiers-502" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-504" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a><a id="plfa_plfa-part1-Quantifiers-508" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-510" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a><a id="plfa_plfa-part1-Quantifiers-514" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-516" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-521" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-528" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Quantifiers-551" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-557" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-558" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4303" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Quantifiers-561" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-563" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2620" class="Postulate">extensionality</a><a id="plfa_plfa-part1-Quantifiers-577" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-579" class="Keyword">open</a> <a id="plfa_plfa-part1-Quantifiers-584" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-591" href="https://agda.github.io/agda-stdlib/v1.7.2/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Quantifiers-600" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-606" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-607" href="https://agda.github.io/agda-stdlib/v1.7.2/Function.Base.html#1040" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Quantifiers-610" class="Symbol">)</a>
</pre><h2 id="universals">Universals</h2><p>We formalise universal quantification using the dependent function type, which has appeared throughout this book. For instance, in Chapter Induction we showed addition is associative:</p><pre><code>+-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)</code></pre><p>which asserts for all natural numbers <code>m</code>, <code>n</code>, and <code>p</code> that <code>(m + n) + p ≡ m + (n + p)</code> holds. It is a dependent function, which given values for <code>m</code>, <code>n</code>, and <code>p</code> returns evidence for the corresponding equation.</p><p>In general, given a variable <code>x</code> of type <code>A</code> and a proposition <code>B x</code> which contains <code>x</code> as a free variable, the universally quantified proposition <code>∀ (x : A) → B x</code> holds if for every term <code>M</code> of type <code>A</code> the proposition <code>B M</code> holds. Here <code>B M</code> stands for the proposition <code>B x</code> with each free occurrence of <code>x</code> replaced by <code>M</code>. Variable <code>x</code> appears free in <code>B x</code> but bound in <code>∀ (x : A) → B x</code>.</p><p>Evidence that <code>∀ (x : A) → B x</code> holds is of the form</p><pre><code>λ (x : A) → N x</code></pre><p>where <code>N x</code> is a term of type <code>B x</code>, and <code>N x</code> and <code>B x</code> both contain a free variable <code>x</code> of type <code>A</code>. Given a term <code>L</code> providing evidence that <code>∀ (x : A) → B x</code> holds, and a term <code>M</code> of type <code>A</code>, the term <code>L M</code> provides evidence that <code>B M</code> holds. In other words, evidence that <code>∀ (x : A) → B x</code> holds is a function that converts a term <code>M</code> of type <code>A</code> into evidence that <code>B M</code> holds.</p>Put another way, if we know that <code>∀ (x : A) → B x</code> holds and that <code>M</code> is a term of type <code>A</code> then we may conclude that <code>B M</code> holds:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∀-elim"></a><a id="plfa_plfa-part1-Quantifiers-2092" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2092" class="Function">∀-elim</a> <a id="plfa_plfa-part1-Quantifiers-2099" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2101" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-2103" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-2104" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2104" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-2106" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2108" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-2111" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-2113" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-2114" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2114" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2116" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2118" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2104" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-2120" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2122" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-2125" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-2129" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2131" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-2132" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2132" class="Bound">L</a> <a id="plfa_plfa-part1-Quantifiers-2134" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2136" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-2138" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-2139" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2139" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-2141" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2143" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2104" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-2144" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-2146" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2148" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2114" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2150" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2139" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-2151" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Quantifiers-2155" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2157" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-2158" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2158" class="Bound">M</a> <a id="plfa_plfa-part1-Quantifiers-2160" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-2162" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2104" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-2163" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Quantifiers-2169" class="Comment">-----------------</a>
  <a id="plfa_plfa-part1-Quantifiers-2189" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-2191" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2114" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-2193" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2158" class="Bound">M</a>
<a id="plfa_plfa-part1-Quantifiers-2195" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2092" class="Function">∀-elim</a> <a id="plfa_plfa-part1-Quantifiers-2202" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2202" class="Bound">L</a> <a id="plfa_plfa-part1-Quantifiers-2204" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2204" class="Bound">M</a> <a id="plfa_plfa-part1-Quantifiers-2206" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-2208" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2202" class="Bound">L</a> <a id="plfa_plfa-part1-Quantifiers-2210" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-2204" class="Bound">M</a>
</pre><p>As with <code>→-elim</code>, the rule corresponds to function application.</p><p>Functions arise as a special case of dependent functions, where the range does not depend on a variable drawn from the domain. When a function is viewed as evidence of implication, both its argument and result are viewed as evidence, whereas when a dependent function is viewed as evidence of a universal, its argument is viewed as an element of a data type and its result is viewed as evidence of a proposition that depends on the argument. This difference is largely a matter of interpretation, since in Agda a value of a type and evidence of a proposition are indistinguishable.</p><p>Dependent function types are sometimes referred to as dependent products, because if <code>A</code> is a finite type with values <code>x₁ , ⋯ , xₙ</code>, and if each of the types <code>B x₁ , ⋯ , B xₙ</code> has <code>m₁ , ⋯ , mₙ</code> distinct members, then <code>∀ (x : A) → B x</code> has <code>m₁ * ⋯ * mₙ</code> members. Indeed, sometimes the notation <code>∀ (x : A) → B x</code> is replaced by a notation such as <code>Π[ x ∈ A ] (B x)</code>, where <code>Π</code> stands for product. However, we will stick with the name dependent function, because (as we will see) dependent product is ambiguous.</p><h4 id="exercise--distrib--recommended">Exercise <code>∀-distrib-×</code> (recommended)</h4>Show that universals distribute over conjunction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-3478" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∀-distrib-×"></a><a id="plfa_plfa-part1-Quantifiers-3490" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3490" class="Postulate">∀-distrib-×</a> <a id="plfa_plfa-part1-Quantifiers-3502" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3504" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-3506" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3507" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3507" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3509" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3511" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3514" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3516" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3517" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3517" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3519" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3519" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3521" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3523" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3507" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3525" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3527" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3530" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3532" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-3538" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3541" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3542" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3542" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3544" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3546" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3507" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3547" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3549" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3551" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3517" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3553" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3542" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3555" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-3557" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3519" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3559" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3542" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3560" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3562" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4303" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-3564" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3567" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3568" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3568" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3570" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3572" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3507" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3573" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3575" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3577" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3517" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3579" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3568" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3580" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3582" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-3584" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3587" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3588" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3588" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3590" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3592" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3507" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3593" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3595" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3597" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3519" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3599" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3588" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3600" class="Symbol">)</a>
</pre><p>Compare this with the result (<code>→-distrib-×</code>) in Chapter <a href="../Connectives/">Connectives</a>.</p><h4 id="exercise--implies--practice">Exercise <code>⊎∀-implies-∀⊎</code> (practice)</h4>Show that a disjunction of universals implies a universal of disjunctions:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-3818" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-⊎∀-implies-∀⊎"></a><a id="plfa_plfa-part1-Quantifiers-3830" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3830" class="Postulate">⊎∀-implies-∀⊎</a> <a id="plfa_plfa-part1-Quantifiers-3844" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3846" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-3848" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3849" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3849" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3851" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3853" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3856" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3858" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-3859" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3859" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3861" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3861" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3863" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3865" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3849" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-3867" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3869" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-3872" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-3874" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-3880" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3883" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3884" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3884" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3886" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3888" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3849" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3889" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3891" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3893" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3859" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3895" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3884" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3896" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3898" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-3900" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-3903" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3904" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3904" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3906" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3908" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3849" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3909" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3911" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3913" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3861" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3915" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3904" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-3916" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3918" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3920" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-3922" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-3923" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3923" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3925" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-3927" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3849" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-3928" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-3930" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-3932" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3859" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-3934" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3923" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-3936" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-3938" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3861" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-3940" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-3923" class="Bound">x</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="exercise---practice">Exercise <code>∀-×</code> (practice)</h4>Consider the following type.<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-4076" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-Tri"></a><a id="plfa_plfa-part1-Quantifiers-4081" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4081" class="Datatype">Tri</a> <a id="plfa_plfa-part1-Quantifiers-4085" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4087" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-4091" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.aa"></a><a id="plfa_plfa-part1-Quantifiers-4099" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4099" class="InductiveConstructor">aa</a> <a id="plfa_plfa-part1-Quantifiers-4102" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4104" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4081" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.bb"></a><a id="plfa_plfa-part1-Quantifiers-4110" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4110" class="InductiveConstructor">bb</a> <a id="plfa_plfa-part1-Quantifiers-4113" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4115" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4081" class="Datatype">Tri</a>
  <a id="plfa_plfa-part1-Quantifiers-Tri.cc"></a><a id="plfa_plfa-part1-Quantifiers-4121" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4121" class="InductiveConstructor">cc</a> <a id="plfa_plfa-part1-Quantifiers-4124" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4126" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4081" class="Datatype">Tri</a>
</pre><p>Let <code>B</code> be a type indexed by <code>Tri</code>, that is <code>B : Tri → Set</code>. Show that <code>∀ (x : Tri) → B x</code> is isomorphic to <code>B aa × B bb × B cc</code>. Hint: you will need to postulate a version of extensionality that works for dependent functions.</p><h2 id="existentials">Existentials</h2><p>Given a variable <code>x</code> of type <code>A</code> and a proposition <code>B x</code> which contains <code>x</code> as a free variable, the existentially quantified proposition <code>Σ[ x ∈ A ] B x</code> holds if for some term <code>M</code> of type <code>A</code> the proposition <code>B M</code> holds. Here <code>B M</code> stands for the proposition <code>B x</code> with each free occurrence of <code>x</code> replaced by <code>M</code>. Variable <code>x</code> appears free in <code>B x</code> but bound in <code>Σ[ x ∈ A ] B x</code>.</p>We formalise existential quantification by declaring a suitable inductive type:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-4853" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-Σ"></a><a id="plfa_plfa-part1-Quantifiers-4858" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4858" class="Datatype">Σ</a> <a id="plfa_plfa-part1-Quantifiers-4860" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4861" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4861" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-4863" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4865" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-4868" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4870" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4871" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4871" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-4873" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4875" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4861" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-4877" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4879" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-4882" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4884" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4886" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-4890" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-Σ.⟨_,_⟩"></a><a id="plfa_plfa-part1-Quantifiers-4898" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="plfa_plfa-part1-Quantifiers-4904" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4906" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-4907" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4907" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-4909" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-4911" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4861" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-4912" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-4914" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4916" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4871" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-4918" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4907" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-4920" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-4922" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4858" class="Datatype">Σ</a> <a id="plfa_plfa-part1-Quantifiers-4924" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4861" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-4926" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4871" class="Bound">B</a>
</pre>We define a convenient syntax for existentials as follows:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-Σ-syntax"></a><a id="plfa_plfa-part1-Quantifiers-4999" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4999" class="Function">Σ-syntax</a> <a id="plfa_plfa-part1-Quantifiers-5008" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-5010" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4858" class="Datatype">Σ</a>
<a id="plfa_plfa-part1-Quantifiers-5012" class="Keyword">infix</a> <a id="plfa_plfa-part1-Quantifiers-5018" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-5020" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4999" class="Function">Σ-syntax</a>
<a id="plfa_plfa-part1-Quantifiers-5029" class="Keyword">syntax</a> <a id="plfa_plfa-part1-Quantifiers-5036" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4999" class="Function">Σ-syntax</a> <a id="plfa_plfa-part1-Quantifiers-5045" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5047" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Quantifiers-5050" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-5052" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-5054" class="Bound">Bx</a><a id="plfa_plfa-part1-Quantifiers-5056" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-5058" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-5060" class="Function">Σ[</a> <a id="plfa_plfa-part1-Quantifiers-5063" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-5065" class="Function">∈</a> <a id="plfa_plfa-part1-Quantifiers-5067" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5069" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-5071" class="Bound">Bx</a>
</pre><p>This is our first use of a syntax declaration, which specifies that the term on the left may be written with the syntax on the right. The special syntax is available only when the identifier <code>Σ-syntax</code> is imported.</p><p>Evidence that <code>Σ[ x ∈ A ] B x</code> holds is of the form <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code>, and <code>N</code> is evidence that <code>B M</code> holds.</p>Equivalently, we could also declare existentials as a record type:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-5505" class="Keyword">record</a> <a id="plfa_plfa-part1-Quantifiers-Σ′"></a><a id="plfa_plfa-part1-Quantifiers-5512" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5512" class="Record">Σ′</a> <a id="plfa_plfa-part1-Quantifiers-5515" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-5516" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5516" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5518" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5520" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-5523" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-5525" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-5526" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5526" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-5528" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5530" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5516" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-5532" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-5534" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-5537" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-5539" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5541" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Quantifiers-5545" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-5553" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Quantifiers-Σ′.proj₁′"></a><a id="plfa_plfa-part1-Quantifiers-5563" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5563" class="Field">proj₁′</a> <a id="plfa_plfa-part1-Quantifiers-5570" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5572" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5516" class="Bound">A</a>
    <a id="plfa_plfa-part1-Quantifiers-Σ′.proj₂′"></a><a id="plfa_plfa-part1-Quantifiers-5578" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5578" class="Field">proj₂′</a> <a id="plfa_plfa-part1-Quantifiers-5585" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-5587" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5526" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-5589" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-5563" class="Field">proj₁′</a>
</pre><p>Here record construction</p><pre><code>record
  { proj₁′ = M
  ; proj₂′ = N
  }</code></pre><p>corresponds to the term</p><pre><code>⟨ M , N ⟩</code></pre><p>where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B M</code>.</p><p>Products arise as a special case of existentials, where the second component does not depend on a variable drawn from the first component. When a product is viewed as evidence of a conjunction, both of its components are viewed as evidence, whereas when it is viewed as evidence of an existential, the first component is viewed as an element of a datatype and the second component is viewed as evidence of a proposition that depends on the first component. This difference is largely a matter of interpretation, since in Agda a value of a type and evidence of a proposition are indistinguishable.</p><p>Existentials are sometimes referred to as dependent sums, because if <code>A</code> is a finite type with values <code>x₁ , ⋯ , xₙ</code>, and if each of the types <code>B x₁ , ⋯ B xₙ</code> has <code>m₁ , ⋯ , mₙ</code> distinct members, then <code>Σ[ x ∈ A ] B x</code> has <code>m₁ + ⋯ + mₙ</code> members, which explains the choice of notation for existentials, since <code>Σ</code> stands for sum.</p><p>Existentials are sometimes referred to as dependent products, since products arise as a special case. However, that choice of names is doubly confusing, since universals also have a claim to the name dependent product and since existentials also have a claim to the name dependent sum.</p>A common notation for existentials is <code>∃</code> (analogous to <code>∀</code> for universals). We follow the convention of the Agda standard library, and reserve this notation for the case where the domain of the bound variable is left implicit:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃"></a><a id="plfa_plfa-part1-Quantifiers-7240" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7240" class="Function">∃</a> <a id="plfa_plfa-part1-Quantifiers-7242" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7244" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-7246" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7247" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7247" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7249" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7251" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7254" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-7256" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-7257" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7257" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7259" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7261" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7247" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7263" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7265" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7268" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-7270" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7272" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Quantifiers-7276" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7240" class="Function">∃</a> <a id="plfa_plfa-part1-Quantifiers-7278" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7279" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7279" class="Bound">A</a><a id="plfa_plfa-part1-Quantifiers-7280" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-7282" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7282" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7284" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-7286" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4858" class="Datatype">Σ</a> <a id="plfa_plfa-part1-Quantifiers-7288" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7279" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7290" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7282" class="Bound">B</a>

<a id="plfa_plfa-part1-Quantifiers-∃-syntax"></a><a id="plfa_plfa-part1-Quantifiers-7293" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃-syntax</a> <a id="plfa_plfa-part1-Quantifiers-7302" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-7304" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7240" class="Function">∃</a>
<a id="plfa_plfa-part1-Quantifiers-7306" class="Keyword">syntax</a> <a id="plfa_plfa-part1-Quantifiers-7313" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃-syntax</a> <a id="plfa_plfa-part1-Quantifiers-7322" class="Symbol">(λ</a> <a id="plfa_plfa-part1-Quantifiers-7325" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7327" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7329" class="Bound">B</a><a id="plfa_plfa-part1-Quantifiers-7330" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-7332" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-7334" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-7337" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7339" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-7341" class="Bound">B</a>
</pre><p>The special syntax is available only when the identifier <code>∃-syntax</code> is imported. We will tend to use this syntax, since it is shorter and more familiar.</p>Given evidence that <code>∀ x → B x → C</code> holds, where <code>C</code> does not contain <code>x</code> as a free variable, and given evidence that <code>∃[ x ] B x</code> holds, we may conclude that <code>C</code> holds:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃-elim"></a><a id="plfa_plfa-part1-Quantifiers-7679" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7679" class="Function">∃-elim</a> <a id="plfa_plfa-part1-Quantifiers-7686" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7688" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-7690" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7691" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7691" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7693" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7695" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7698" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-7700" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7701" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7701" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7703" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7705" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7691" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-7707" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7709" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7712" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-7714" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-7715" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7715" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-7717" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-7719" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-7722" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-7726" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7728" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-7731" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7731" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7733" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7735" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7701" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7737" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7731" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7739" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7741" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7715" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-7742" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Quantifiers-7746" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7748" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-7751" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7751" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7753" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-7755" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7701" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-7757" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7751" class="Bound">x</a>
    <a id="plfa_plfa-part1-Quantifiers-7763" class="Comment">---------------</a>
  <a id="plfa_plfa-part1-Quantifiers-7781" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-7783" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7715" class="Bound">C</a>
<a id="plfa_plfa-part1-Quantifiers-7785" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7679" class="Function">∃-elim</a> <a id="plfa_plfa-part1-Quantifiers-7792" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7792" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-7794" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-7796" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7796" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7798" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-7800" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7800" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-7802" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-7804" class="Symbol">=</a> <a id="plfa_plfa-part1-Quantifiers-7806" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7792" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-7808" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7796" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-7810" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7800" class="Bound">y</a>
</pre><p>In other words, if we know for every <code>x</code> of type <code>A</code> that <code>B x</code> implies <code>C</code>, and we know for some <code>x</code> of type <code>A</code> that <code>B x</code> holds, then we may conclude that <code>C</code> holds. This is because we may instantiate that proof that <code>∀ x → B x → C</code> to any value <code>x</code> of type <code>A</code> and any <code>y</code> of type <code>B x</code>, and exactly such values are provided by the evidence for <code>∃[ x ] B x</code>.</p>Indeed, the converse also holds, and the two together form an isomorphism:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∀∃-currying"></a><a id="plfa_plfa-part1-Quantifiers-8264" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8264" class="Function">∀∃-currying</a> <a id="plfa_plfa-part1-Quantifiers-8276" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8278" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-8280" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8281" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8281" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8283" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8285" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8288" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8290" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8291" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8291" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8293" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8295" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8281" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8297" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8299" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8302" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8304" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8305" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8305" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-8307" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8309" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8312" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-8316" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8318" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-8321" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8321" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8323" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8325" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8291" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8327" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8321" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8329" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8331" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8305" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-8332" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-8334" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4303" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-8336" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-8337" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-8340" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8340" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8342" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-8344" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8291" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8346" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8340" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8348" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8350" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8305" class="Bound">C</a><a id="plfa_plfa-part1-Quantifiers-8351" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-8353" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8264" class="Function">∀∃-currying</a> <a id="plfa_plfa-part1-Quantifiers-8365" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Quantifiers-8369" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Quantifiers-8380" class="Symbol">{</a> <a id="plfa_plfa-part1-Quantifiers-8382" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4343" class="Field">to</a>      <a id="plfa_plfa-part1-Quantifiers-8390" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-8393" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8396" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8396" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-8398" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8400" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8403" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-8405" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8405" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8407" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-8409" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8409" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8411" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-8413" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8415" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8396" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-8417" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8405" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8419" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8409" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8421" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Quantifiers-8428" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-8430" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4360" class="Field">from</a>    <a id="plfa_plfa-part1-Quantifiers-8438" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-8441" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8444" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8444" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-8446" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8448" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8451" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8451" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8453" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8455" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8458" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8458" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8460" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8462" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8444" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-8464" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-8466" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8451" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8468" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-8470" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8458" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8472" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-8474" class="Symbol">}}}</a>
    <a id="plfa_plfa-part1-Quantifiers-8482" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-8484" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4377" class="Field">from∘to</a> <a id="plfa_plfa-part1-Quantifiers-8492" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-8495" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8498" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8498" class="Bound">f</a> <a id="plfa_plfa-part1-Quantifiers-8500" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8502" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-8507" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-8513" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-8515" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4419" class="Field">to∘from</a> <a id="plfa_plfa-part1-Quantifiers-8523" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-8526" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8529" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8529" class="Bound">g</a> <a id="plfa_plfa-part1-Quantifiers-8531" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8533" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2620" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Quantifiers-8548" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-8551" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-8553" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8553" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8555" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-8557" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8557" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-8559" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-8561" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8563" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-8568" class="Symbol">}}</a>
    <a id="plfa_plfa-part1-Quantifiers-8575" class="Symbol">}</a>
</pre><p>The result can be viewed as a generalisation of currying. Indeed, the code to establish the isomorphism is identical to what we wrote when discussing <a href="../Connectives/#implication">implication</a>.</p><h4 id="exercise--distrib--recommended-1">Exercise <code>∃-distrib-⊎</code> (recommended)</h4>Show that existentials distribute over disjunction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-8878" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃-distrib-⊎"></a><a id="plfa_plfa-part1-Quantifiers-8890" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8890" class="Postulate">∃-distrib-⊎</a> <a id="plfa_plfa-part1-Quantifiers-8902" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8904" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-8906" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8907" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8907" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8909" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8911" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8914" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8916" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-8917" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8917" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8919" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8919" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-8921" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-8923" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8907" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-8925" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-8927" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-8930" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-8932" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-8938" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-8941" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8941" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8943" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-8945" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-8946" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8917" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8948" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8941" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8950" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-8952" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8919" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-8954" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8941" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-8955" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-8957" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4303" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-8959" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-8960" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-8963" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8963" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8965" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-8967" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8917" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-8969" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8963" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-8970" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-8972" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="plfa_plfa-part1-Quantifiers-8974" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-8975" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-8978" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8978" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-8980" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-8982" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8919" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-8984" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-8978" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-8985" class="Symbol">)</a>
</pre><h4 id="exercise--implies--practice-1">Exercise <code>∃×-implies-×∃</code> (practice)</h4>Show that an existential of conjunctions implies a conjunction of existentials:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-9122" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃×-implies-×∃"></a><a id="plfa_plfa-part1-Quantifiers-9134" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9134" class="Postulate">∃×-implies-×∃</a> <a id="plfa_plfa-part1-Quantifiers-9148" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9150" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9152" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9153" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9153" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9155" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9157" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9160" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9162" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9163" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9163" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9165" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9165" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9167" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9169" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9153" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-9171" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9173" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-9176" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-9178" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Quantifiers-9184" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9187" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9187" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9189" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9191" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9192" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9163" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9194" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9187" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9196" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-9198" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9165" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9200" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9187" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9201" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9203" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9205" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9206" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9209" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9209" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9211" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9213" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9163" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-9215" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9209" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9216" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-9218" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">×</a> <a id="plfa_plfa-part1-Quantifiers-9220" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9221" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-9224" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9224" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-9226" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-9228" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9165" class="Bound">C</a> <a id="plfa_plfa-part1-Quantifiers-9230" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9224" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-9231" class="Symbol">)</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="exercise---practice-1">Exercise <code>∃-⊎</code> (practice)</h4><p>Let <code>Tri</code> and <code>B</code> be as in Exercise <code>∀-×</code>. Show that <code>∃[ x ] B x</code> is isomorphic to <code>B aa ⊎ B bb ⊎ B cc</code>.</p><h2 id="an-existential-example">An existential example</h2>Recall the definitions of <code>even</code> and <code>odd</code> from Chapter <a href="../Relations/">Relations</a>:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-9553" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-even"></a><a id="plfa_plfa-part1-Quantifiers-9558" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9558" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9563" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9565" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Quantifiers-9567" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9569" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Quantifiers-9573" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-odd"></a><a id="plfa_plfa-part1-Quantifiers-9578" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9578" class="Datatype">odd</a>  <a id="plfa_plfa-part1-Quantifiers-9583" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9585" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Quantifiers-9587" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9589" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a>

<a id="plfa_plfa-part1-Quantifiers-9594" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-9599" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9558" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9604" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Quantifiers-even.even-zero"></a><a id="plfa_plfa-part1-Quantifiers-9613" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9613" class="InductiveConstructor">even-zero</a> <a id="plfa_plfa-part1-Quantifiers-9623" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9625" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9558" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9630" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>

  <a id="plfa_plfa-part1-Quantifiers-even.even-suc"></a><a id="plfa_plfa-part1-Quantifiers-9638" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9638" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-9647" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9649" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9651" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9652" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9652" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-9654" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9656" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-9657" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-9663" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9665" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9578" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-9669" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9652" class="Bound">n</a>
      <a id="plfa_plfa-part1-Quantifiers-9677" class="Comment">------------</a>
    <a id="plfa_plfa-part1-Quantifiers-9694" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9696" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9558" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9701" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9702" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-9706" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9652" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-9707" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-9710" class="Keyword">data</a> <a id="plfa_plfa-part1-Quantifiers-9715" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9578" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-9719" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Quantifiers-odd.odd-suc"></a><a id="plfa_plfa-part1-Quantifiers-9727" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9727" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-9735" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9737" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-9739" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-9740" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9740" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-9742" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-9744" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-9745" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-9751" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9753" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9558" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-9758" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9740" class="Bound">n</a>
      <a id="plfa_plfa-part1-Quantifiers-9766" class="Comment">-----------</a>
    <a id="plfa_plfa-part1-Quantifiers-9782" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-9784" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9578" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-9788" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-9789" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-9793" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9740" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-9794" class="Symbol">)</a>
</pre><p>A number is even if it is zero or the successor of an odd number, and odd if it is the successor of an even number.</p><p>We will show that a number is even if and only if it is twice some other number, and odd if and only if it is one more than twice some other number. In other words, we will show:</p><p><code>even n</code> iff <code>∃[ m ] ( m * 2 ≡ n)</code></p><p><code>odd n</code> iff <code>∃[ m ] (1 + m * 2 ≡ n)</code></p><p>By convention, one tends to write constant factors first and to put the constant term in a sum last. Here we’ve reversed each of those conventions, because doing so eases the proof.</p>Here is the proof in the forward direction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-even-∃"></a><a id="plfa_plfa-part1-Quantifiers-10419" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10419" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-10426" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10428" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-10430" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-10431" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10431" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10433" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10435" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-10436" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-10438" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10440" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9558" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-10445" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10431" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10447" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10449" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-10452" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10452" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10454" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-10456" class="Symbol">(</a>    <a id="plfa_plfa-part1-Quantifiers-10461" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10452" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10463" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-10465" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-10467" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-10469" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10431" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-10470" class="Symbol">)</a>
<a id="plfa_plfa-part1-Quantifiers-odd-∃"></a><a id="plfa_plfa-part1-Quantifiers-10472" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10472" class="Function">odd-∃</a>  <a id="plfa_plfa-part1-Quantifiers-10479" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10481" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-10483" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-10484" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10484" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10486" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-10488" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-10489" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-10491" class="Symbol">→</a>  <a id="plfa_plfa-part1-Quantifiers-10494" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9578" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-10498" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10484" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-10500" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-10502" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-10505" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10505" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10507" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-10509" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10510" class="Number">1</a> <a id="plfa_plfa-part1-Quantifiers-10512" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Quantifiers-10514" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10505" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10516" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-10518" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-10520" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-10522" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10484" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-10523" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-10526" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10419" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-10533" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9613" class="InductiveConstructor">even-zero</a>                       <a id="plfa_plfa-part1-Quantifiers-10565" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-10568" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10570" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Quantifiers-10575" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10577" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10582" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a>
<a id="plfa_plfa-part1-Quantifiers-10584" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10419" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-10591" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10592" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9638" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-10601" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10601" class="Bound">o</a><a id="plfa_plfa-part1-Quantifiers-10602" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-10604" class="Keyword">with</a> <a id="plfa_plfa-part1-Quantifiers-10609" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10472" class="Function">odd-∃</a> <a id="plfa_plfa-part1-Quantifiers-10615" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10601" class="Bound">o</a>
<a id="plfa_plfa-part1-Quantifiers-10617" class="Symbol">...</a>                    <a id="plfa_plfa-part1-Quantifiers-10640" class="Symbol">|</a> <a id="plfa_plfa-part1-Quantifiers-10642" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10644" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10644" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10646" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10648" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10653" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-10656" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-10659" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10661" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-10665" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10644" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10667" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10669" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10674" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a>

<a id="plfa_plfa-part1-Quantifiers-10677" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10472" class="Function">odd-∃</a>  <a id="plfa_plfa-part1-Quantifiers-10684" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-10685" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9727" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-10693" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10693" class="Bound">e</a><a id="plfa_plfa-part1-Quantifiers-10694" class="Symbol">)</a>  <a id="plfa_plfa-part1-Quantifiers-10697" class="Keyword">with</a> <a id="plfa_plfa-part1-Quantifiers-10702" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10419" class="Function">even-∃</a> <a id="plfa_plfa-part1-Quantifiers-10709" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10693" class="Bound">e</a>
<a id="plfa_plfa-part1-Quantifiers-10711" class="Symbol">...</a>                    <a id="plfa_plfa-part1-Quantifiers-10734" class="Symbol">|</a> <a id="plfa_plfa-part1-Quantifiers-10736" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10738" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10738" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10740" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10742" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10747" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-10750" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-10753" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-10755" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-10738" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-10757" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-10759" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-10764" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a>
</pre><p>We define two mutually recursive functions. Given evidence that <code>n</code> is even or odd, we return a number <code>m</code> and evidence that <code>m * 2 ≡ n</code> or <code>1 + m * 2 ≡ n</code>. We induct over the evidence that <code>n</code> is even or odd:</p><ul><li><p>If the number is even because it is zero, then we return a pair consisting of zero and the evidence that twice zero is zero.</p></li><li><p>If the number is even because it is one more than an odd number, then we apply the induction hypothesis to give a number <code>m</code> and evidence that <code>1 + m * 2 ≡ n</code>. We return a pair consisting of <code>suc m</code> and evidence that <code>suc m * 2 ≡ suc n</code>, which is immediate after substituting for <code>n</code>.</p></li><li><p>If the number is odd because it is the successor of an even number, then we apply the induction hypothesis to give a number <code>m</code> and evidence that <code>m * 2 ≡ n</code>. We return a pair consisting of <code>m</code> and evidence that <code>1 + m * 2 ≡ suc n</code>, which is immediate after substituting for <code>n</code>.</p></li></ul><p>This completes the proof in the forward direction.</p>Here is the proof in the reverse direction:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-∃-even"></a><a id="plfa_plfa-part1-Quantifiers-11784" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11784" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-11791" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11793" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-11795" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-11796" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11796" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-11798" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11800" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-11801" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-11803" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11805" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-11808" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11808" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11810" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-11812" class="Symbol">(</a>    <a id="plfa_plfa-part1-Quantifiers-11817" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11808" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11819" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-11821" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-11823" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-11825" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11796" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-11826" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-11828" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11830" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9558" class="Datatype">even</a> <a id="plfa_plfa-part1-Quantifiers-11835" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11796" class="Bound">n</a>
<a id="plfa_plfa-part1-Quantifiers-∃-odd"></a><a id="plfa_plfa-part1-Quantifiers-11837" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11837" class="Function">∃-odd</a>  <a id="plfa_plfa-part1-Quantifiers-11844" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11846" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-11848" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-11849" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11849" class="Bound">n</a> <a id="plfa_plfa-part1-Quantifiers-11851" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-11853" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Quantifiers-11854" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-11856" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-11858" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-11861" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11861" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11863" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-11865" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-11866" class="Number">1</a> <a id="plfa_plfa-part1-Quantifiers-11868" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Quantifiers-11870" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11861" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11872" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="plfa_plfa-part1-Quantifiers-11874" class="Number">2</a> <a id="plfa_plfa-part1-Quantifiers-11876" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Quantifiers-11878" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11849" class="Bound">n</a><a id="plfa_plfa-part1-Quantifiers-11879" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-11881" class="Symbol">→</a>  <a id="plfa_plfa-part1-Quantifiers-11884" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9578" class="Datatype">odd</a> <a id="plfa_plfa-part1-Quantifiers-11888" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11849" class="Bound">n</a>

<a id="plfa_plfa-part1-Quantifiers-11891" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11784" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-11898" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a>  <a id="plfa_plfa-part1-Quantifiers-11901" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="plfa_plfa-part1-Quantifiers-11906" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-11908" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-11913" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-11916" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-11919" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9613" class="InductiveConstructor">even-zero</a>
<a id="plfa_plfa-part1-Quantifiers-11929" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11784" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-11936" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-11938" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Quantifiers-11942" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11942" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11944" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-11946" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-11951" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-11954" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-11957" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9638" class="InductiveConstructor">even-suc</a> <a id="plfa_plfa-part1-Quantifiers-11966" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-11967" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11837" class="Function">∃-odd</a> <a id="plfa_plfa-part1-Quantifiers-11973" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-11975" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11942" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-11977" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-11979" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-11984" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Quantifiers-11985" class="Symbol">)</a>

<a id="plfa_plfa-part1-Quantifiers-11988" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11837" class="Function">∃-odd</a>  <a id="plfa_plfa-part1-Quantifiers-11995" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a>     <a id="plfa_plfa-part1-Quantifiers-12001" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12001" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12003" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12005" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12010" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a>  <a id="plfa_plfa-part1-Quantifiers-12013" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-12016" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-9727" class="InductiveConstructor">odd-suc</a> <a id="plfa_plfa-part1-Quantifiers-12024" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-12025" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-11784" class="Function">∃-even</a> <a id="plfa_plfa-part1-Quantifiers-12032" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-12034" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-12001" class="Bound">m</a> <a id="plfa_plfa-part1-Quantifiers-12036" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-12038" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-12043" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a><a id="plfa_plfa-part1-Quantifiers-12044" class="Symbol">)</a>
</pre><p>Given a number that is twice some other number we must show it is even, and a number that is one more than twice some other number we must show it is odd. We induct over the evidence of the existential, and in the even case consider the two possibilities for the number that is doubled:</p><ul><li><p>In the even case for <code>zero</code>, we must show <code>zero * 2</code> is even, which follows by <code>even-zero</code>.</p></li><li><p>In the even case for <code>suc n</code>, we must show <code>suc m * 2</code> is even. The inductive hypothesis tells us that <code>1 + m * 2</code> is odd, from which the desired result follows by <code>even-suc</code>.</p></li><li><p>In the odd case, we must show <code>1 + m * 2</code> is odd. The inductive hypothesis tell us that <code>m * 2</code> is even, from which the desired result follows by <code>odd-suc</code>.</p></li></ul><p>This completes the proof in the backward direction.</p><h4 id="exercise--even-odd-practice">Exercise <code>∃-even-odd</code> (practice)</h4><p>How do the proofs become more difficult if we replace <code>m * 2</code> and <code>1 + m * 2</code> by <code>2 * m</code> and <code>2 * m + 1</code>? Rewrite the proofs of <code>∃-even</code> and <code>∃-odd</code> when restated in this way.</p><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-13053" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise----practice">Exercise <code>∃-+-≤</code> (practice)</h4><p>Show that <code>y ≤ z</code> holds if and only if there exists a <code>x</code> such that <code>x + y ≡ z</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-13205" class="Comment">-- Your code goes here</a>
</pre><h2 id="existentials-universals-and-negation">Existentials, Universals, and Negation</h2>Negation of an existential is isomorphic to the universal of a negation. Considering that existentials are generalised disjunction and universals are generalised conjunction, this result is analogous to the one which tells us that negation of a disjunction is isomorphic to a conjunction of negations:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-¬∃≃∀¬"></a><a id="plfa_plfa-part1-Quantifiers-13588" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13588" class="Function">¬∃≃∀¬</a> <a id="plfa_plfa-part1-Quantifiers-13594" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-13596" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-13598" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-13599" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13599" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-13601" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-13603" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-13606" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-13608" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-13609" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13609" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-13611" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-13613" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13599" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-13615" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13617" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-13620" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Quantifiers-13624" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13626" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-13627" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-13629" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-13632" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13632" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13634" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-13636" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13609" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-13638" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13632" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-13639" class="Symbol">)</a> <a id="plfa_plfa-part1-Quantifiers-13641" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4303" class="Record Operator">≃</a> <a id="plfa_plfa-part1-Quantifiers-13643" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-13645" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13645" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13647" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13649" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-13651" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13609" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-13653" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13645" class="Bound">x</a>
<a id="plfa_plfa-part1-Quantifiers-13655" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13588" class="Function">¬∃≃∀¬</a> <a id="plfa_plfa-part1-Quantifiers-13661" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Quantifiers-13665" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Quantifiers-13676" class="Symbol">{</a> <a id="plfa_plfa-part1-Quantifiers-13678" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4343" class="Field">to</a>      <a id="plfa_plfa-part1-Quantifiers-13686" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-13689" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13692" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13692" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-13697" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13697" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13699" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13699" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13701" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13703" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13692" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-13708" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-13710" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13697" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13712" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-13714" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13699" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13716" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-13718" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-13724" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-13726" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4360" class="Field">from</a>    <a id="plfa_plfa-part1-Quantifiers-13734" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-13737" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13740" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13740" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-13745" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-13747" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13747" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13749" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-13751" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13751" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13753" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-13755" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13757" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13740" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-13762" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13747" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13764" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13751" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13766" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-13772" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-13774" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4377" class="Field">from∘to</a> <a id="plfa_plfa-part1-Quantifiers-13782" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-13785" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13788" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13788" class="Bound">¬∃xy</a> <a id="plfa_plfa-part1-Quantifiers-13793" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13795" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-2620" class="Postulate">extensionality</a> <a id="plfa_plfa-part1-Quantifiers-13810" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13813" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Quantifiers-13815" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13815" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-13817" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Quantifiers-13819" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13819" class="Bound">y</a> <a id="plfa_plfa-part1-Quantifiers-13821" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-4898" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Quantifiers-13823" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13825" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-13830" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-13832" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-13838" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-13840" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4419" class="Field">to∘from</a> <a id="plfa_plfa-part1-Quantifiers-13848" class="Symbol">=</a>  <a id="plfa_plfa-part1-Quantifiers-13851" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Quantifiers-13854" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-13854" class="Bound">∀¬xy</a> <a id="plfa_plfa-part1-Quantifiers-13859" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-13861" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="plfa_plfa-part1-Quantifiers-13866" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-13872" class="Symbol">}</a>
</pre><p>In the <code>to</code> direction, we are given a value <code>¬∃xy</code> of type <code>¬ ∃[ x ] B x</code>, and need to show that given a value <code>x</code> that <code>¬ B x</code> follows, in other words, from a value <code>y</code> of type <code>B x</code> we can derive false. Combining <code>x</code> and <code>y</code> gives us a value <code>⟨ x , y ⟩</code> of type <code>∃[ x ] B x</code>, and applying <code>¬∃xy</code> to that yields a contradiction.</p><p>In the <code>from</code> direction, we are given a value <code>∀¬xy</code> of type <code>∀ x → ¬ B x</code>, and need to show that from a value <code>⟨ x , y ⟩</code> of type <code>∃[ x ] B x</code> we can derive false. Applying <code>∀¬xy</code> to <code>x</code> gives a value of type <code>¬ B x</code>, and applying that to <code>y</code> yields a contradiction.</p><p>The two inverse proofs are straightforward, where one direction requires extensionality.</p><h4 id="exercise--implies--recommended">Exercise <code>∃¬-implies-¬∀</code> (recommended)</h4>Show that existential of a negation implies negation of a universal:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-14693" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Quantifiers-∃¬-implies-¬∀"></a><a id="plfa_plfa-part1-Quantifiers-14705" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14705" class="Postulate">∃¬-implies-¬∀</a> <a id="plfa_plfa-part1-Quantifiers-14719" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14721" class="Symbol">∀</a> <a id="plfa_plfa-part1-Quantifiers-14723" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-14724" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14724" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-14726" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14728" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-14731" class="Symbol">}</a> <a id="plfa_plfa-part1-Quantifiers-14733" class="Symbol">{</a><a id="plfa_plfa-part1-Quantifiers-14734" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14734" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14736" class="Symbol">:</a> <a id="plfa_plfa-part1-Quantifiers-14738" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14724" class="Bound">A</a> <a id="plfa_plfa-part1-Quantifiers-14740" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14742" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Quantifiers-14745" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Quantifiers-14751" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14753" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">∃[</a> <a id="plfa_plfa-part1-Quantifiers-14756" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14756" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14758" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-7293" class="Function">]</a> <a id="plfa_plfa-part1-Quantifiers-14760" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-14761" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-14763" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14734" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14765" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14756" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-14766" class="Symbol">)</a>
      <a id="plfa_plfa-part1-Quantifiers-14774" class="Comment">--------------</a>
    <a id="plfa_plfa-part1-Quantifiers-14793" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14795" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Quantifiers-14797" class="Symbol">(∀</a> <a id="plfa_plfa-part1-Quantifiers-14800" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14800" class="Bound">x</a> <a id="plfa_plfa-part1-Quantifiers-14802" class="Symbol">→</a> <a id="plfa_plfa-part1-Quantifiers-14804" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14734" class="Bound">B</a> <a id="plfa_plfa-part1-Quantifiers-14806" href="../Quantifiers/#plfa_plfa-part1-Quantifiers-14800" class="Bound">x</a><a id="plfa_plfa-part1-Quantifiers-14807" class="Symbol">)</a>
</pre><p>Does the converse hold? If so, prove; if not, explain why.</p><h4 id="Bin-isomorphism">Exercise <code>Bin-isomorphism</code> (stretch)</h4><p>Recall that Exercises <a href="../Naturals/#Bin">Bin</a>, <a href="../Induction/#Bin-laws">Bin-laws</a>, and <a href="../Relations/#Bin-predicates">Bin-predicates</a> define a datatype <code>Bin</code> of bitstrings representing natural numbers, and asks you to define the following functions and predicates:</p><pre><code>to   : ℕ → Bin
from : Bin → ℕ
Can  : Bin → Set</code></pre><p>And to establish the following properties:</p><pre><code>from (to n) ≡ n

----------
Can (to n)

Can b
---------------
to (from b) ≡ b</code></pre><p>Using the above, establish that there is an isomorphism between <code>ℕ</code> and <code>∃[ b ] Can b</code>.</p><p>We recommend proving the following lemmas which show that, for a given binary number <code>b</code>, there is only one proof of <code>One b</code> and similarly for <code>Can b</code>.</p><pre><code>≡One : ∀ {b : Bin} (o o′ : One b) → o ≡ o′

≡Can : ∀ {b : Bin} (cb cb′ : Can b) → cb ≡ cb′</code></pre><p>Many of the alternatives for proving <code>to∘from</code> turn out to be tricky. However, the proof can be straightforward if you use the following lemma, which is a corollary of <code>≡Can</code>.</p><pre><code>proj₁≡→Can≡ : {cb cb′ : ∃[ b ] Can b} → proj₁ cb ≡ proj₁ cb′ → cb ≡ cb′</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-16007" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard library</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Quantifiers-16148" class="Keyword">import</a> <a id="plfa_plfa-part1-Quantifiers-16155" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Quantifiers-16168" class="Keyword">using</a> <a id="plfa_plfa-part1-Quantifiers-16174" class="Symbol">(</a><a id="plfa_plfa-part1-Quantifiers-16175" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Sigma.html#148" class="Record">Σ</a><a id="plfa_plfa-part1-Quantifiers-16176" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16178" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="plfa_plfa-part1-Quantifiers-16181" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16183" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1378" class="Function">∃</a><a id="plfa_plfa-part1-Quantifiers-16184" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16186" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#925" class="Function">Σ-syntax</a><a id="plfa_plfa-part1-Quantifiers-16194" class="Symbol">;</a> <a id="plfa_plfa-part1-Quantifiers-16196" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1815" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Quantifiers-16204" class="Symbol">)</a>
</pre><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>Π  U+03A0  GREEK CAPITAL LETTER PI (\Pi)
Σ  U+03A3  GREEK CAPITAL LETTER SIGMA (\Sigma)
∃  U+2203  THERE EXISTS (\ex, \exists)</code></pre></div><nav class="pager"><ul class="pagination"><li><a class="pagelink" href="../Negation/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Quantifiers.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Decidable/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>