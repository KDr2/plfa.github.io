<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="../assets/css/light.css" integrity="sha512-J8Ko83OT11zQ2/+vowqJ0Ovx2JEWUBNPTbNptixluYAHAO009R7GVxRQNKA+Wq4skbsdZr1AEOjF2AeQmKt3/A==" title="Light" id="stylesheet-light"><link rel="stylesheet" href="../assets/css/dark.css" integrity="sha512-kK/Wf2991I8CFsf5/Qu/2GIm2Enzw8H70RQ/yHNIb6iGTPF/SKE0B+kxTG2HjcFOgcjfKxZ9Jr4bvSfuKraNWw==" title="Dark" id="stylesheet-dark" disabled><title>Programming Language Foundations in Agda – Lists</title><script src="../assets/js/anchor.js" integrity="sha512-Y5IMGqYQp36NYYdEL6gXISLsHNpx0LxW0NS0twvYBvXI8GH5PZa1g5gm1B5lxg6tlFyUAiOOfgKL/NIn0dtY4w==" id="script-anchor"></script><script src="../assets/js/darkmode.js" integrity="sha512-iUX9HnSphH4WbMv88MYJEFtLfkCtTHrvWyFwjigSm5GkwHv1L31GP5grIGDo7kI2jftuYVvt4xu4qeCn2fKbww==" id="script-darkmode"></script><script src="../assets/js/main.js" integrity="sha512-X7aZg6IUKq1TvTVjSureaMGKZ/ylbAD7kxiU2w42IUgh4lUTWoOsoIWzNvrqkwBJdQ1y2GsS67gtsv39Uuq6ew==" id="script-main"></script></head><body><header class="site-header" aria-label="Site"><div class="wrapper"><a class="site-title" href="../">Programming Language Foundations in Agda</a><nav class="site-nav" aria-label="Site"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger"><span class="menu-icon"><svg class="svg-icon grey" viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path></svg></span></label><div class="trigger"><a class="page-link" href="../">The Book</a> <a class="page-link" href="../Announcements/">Announcements</a> <a class="page-link" href="../GettingStarted/">Getting Started</a> <a class="page-link" href="../Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a> <a class="page-link" onclick="window.darkmode.toggle()"><i id="darkmode-trigger" class="fas fa-moon"></i> </a><a class="page-link" href="../plfa.epub"><i class="fa fa-book"></i></a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">Next</a></li><li class="separator">•</li></ul></nav><header class="post-header" aria-label="Chapter"><h1 class="post-title">Lists: Lists and higher-order functions</h1></header><div class="post-content"><pre class="Agda"><a id="plfa_plfa-part1-Lists-92" class="Keyword">module</a> <a id="plfa_plfa-part1-Lists-99" href="../Lists/#" class="Module">plfa.part1.Lists</a> <a id="plfa_plfa-part1-Lists-116" class="Keyword">where</a>
</pre><p>This chapter discusses the list data type. It gives further examples of many of the techniques we have developed so far, and provides examples of polymorphic types and higher-order functions.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="plfa_plfa-part1-Lists-341" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-348" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="plfa_plfa-part1-Lists-386" class="Symbol">as</a> <a id="plfa_plfa-part1-Lists-389" class="Module">Eq</a>
<a id="plfa_plfa-part1-Lists-392" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-397" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="plfa_plfa-part1-Lists-400" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-406" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-407" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="plfa_plfa-part1-Lists-410" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-412" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-416" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-418" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a><a id="plfa_plfa-part1-Lists-421" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-423" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1738" class="Function">trans</a><a id="plfa_plfa-part1-Lists-428" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-430" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1139" class="Function">cong</a><a id="plfa_plfa-part1-Lists-434" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-436" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-441" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2717" class="Module">Eq.≡-Reasoning</a>
<a id="plfa_plfa-part1-Lists-456" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-461" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-468" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Bool.html" class="Module">Data.Bool</a> <a id="plfa_plfa-part1-Lists-478" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-484" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-485" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-489" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-491" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="plfa_plfa-part1-Lists-495" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-497" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="plfa_plfa-part1-Lists-502" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-504" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Bool.Base.html#1460" class="Function">T</a><a id="plfa_plfa-part1-Lists-505" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-507" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Bool.Base.html#995" class="Function Operator">_∧_</a><a id="plfa_plfa-part1-Lists-510" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-512" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="plfa_plfa-part1-Lists-515" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-517" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Bool.Base.html#941" class="Function">not</a><a id="plfa_plfa-part1-Lists-520" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-522" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-527" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-534" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.html" class="Module">Data.Nat</a> <a id="plfa_plfa-part1-Lists-543" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-549" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-550" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-551" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-553" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-557" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-559" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="plfa_plfa-part1-Lists-562" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-564" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="plfa_plfa-part1-Lists-567" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-569" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a><a id="plfa_plfa-part1-Lists-572" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-574" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#2883" class="Primitive Operator">_∸_</a><a id="plfa_plfa-part1-Lists-577" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-579" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a><a id="plfa_plfa-part1-Lists-582" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-584" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1609" class="InductiveConstructor">s≤s</a><a id="plfa_plfa-part1-Lists-587" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-589" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-592" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-594" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-599" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-606" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="plfa_plfa-part1-Lists-626" class="Keyword">using</a>
  <a id="plfa_plfa-part1-Lists-634" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-635" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#13071" class="Function">+-assoc</a><a id="plfa_plfa-part1-Lists-642" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-644" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#13172" class="Function">+-identityˡ</a><a id="plfa_plfa-part1-Lists-655" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-657" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#13227" class="Function">+-identityʳ</a><a id="plfa_plfa-part1-Lists-668" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-670" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#21055" class="Function">*-assoc</a><a id="plfa_plfa-part1-Lists-677" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-679" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#19955" class="Function">*-identityˡ</a><a id="plfa_plfa-part1-Lists-690" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-692" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#20019" class="Function">*-identityʳ</a><a id="plfa_plfa-part1-Lists-703" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-705" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#20569" class="Function">*-distribʳ-+</a><a id="plfa_plfa-part1-Lists-717" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-719" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-724" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-731" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="plfa_plfa-part1-Lists-748" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-754" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-755" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#665" class="Function Operator">¬_</a><a id="plfa_plfa-part1-Lists-757" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-759" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1520" class="Record">Dec</a><a id="plfa_plfa-part1-Lists-762" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-764" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1657" class="InductiveConstructor">yes</a><a id="plfa_plfa-part1-Lists-767" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-769" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1694" class="InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-771" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-773" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-778" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-785" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html" class="Module">Data.Product</a> <a id="plfa_plfa-part1-Lists-798" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-804" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-805" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">_×_</a><a id="plfa_plfa-part1-Lists-808" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-810" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1378" class="Function">∃</a><a id="plfa_plfa-part1-Lists-811" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-813" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1815" class="Function">∃-syntax</a><a id="plfa_plfa-part1-Lists-821" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-823" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-832" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-833" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a> <a id="plfa_plfa-part1-Lists-837" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="plfa_plfa-part1-Lists-845" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-847" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-852" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-859" href="https://agda.github.io/agda-stdlib/v1.7.2/Function.html" class="Module">Function</a> <a id="plfa_plfa-part1-Lists-868" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-874" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-875" href="https://agda.github.io/agda-stdlib/v1.7.2/Function.Base.html#1040" class="Function Operator">_∘_</a><a id="plfa_plfa-part1-Lists-878" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-880" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-885" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-892" href="https://agda.github.io/agda-stdlib/v1.7.2/Level.html" class="Module">Level</a> <a id="plfa_plfa-part1-Lists-898" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-904" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-905" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#591" class="Postulate">Level</a><a id="plfa_plfa-part1-Lists-910" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-912" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-917" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-924" href="../Isomorphism/#" class="Module">plfa.part1.Isomorphism</a> <a id="plfa_plfa-part1-Lists-947" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-953" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-954" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-4303" class="Record Operator">_≃_</a><a id="plfa_plfa-part1-Lists-957" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-959" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12023" class="Record Operator">_⇔_</a><a id="plfa_plfa-part1-Lists-962" class="Symbol">)</a>
</pre><h2 id="lists">Lists</h2>Lists are defined in Agda as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-1026" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List"></a><a id="plfa_plfa-part1-Lists-1031" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1036" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-1037" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1039" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1041" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-1044" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-1046" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1048" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-1052" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List.[]"></a><a id="plfa_plfa-part1-Lists-1060" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-1064" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1066" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1071" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List._∷_"></a><a id="plfa_plfa-part1-Lists-1075" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-1079" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1081" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1083" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1085" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1090" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-1092" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-1094" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1099" href="../Lists/#plfa_plfa-part1-Lists-1037" class="Bound">A</a>

<a id="plfa_plfa-part1-Lists-1102" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-1109" class="Number">5</a> <a id="plfa_plfa-part1-Lists-1111" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a>
</pre><p>Let’s unpack this definition. If <code>A</code> is a set, then <code>List A</code> is a set. The next two lines tell us that <code>[]</code> (pronounced <em>nil</em>) is a list of type <code>A</code> (often called the <em>empty</em> list), and that <code>_∷_</code> (pronounced <em>cons</em>, short for <em>constructor</em>) takes a value of type <code>A</code> and a value of type <code>List A</code> and returns a value of type <code>List A</code>. Operator <code>_∷_</code> has precedence level 5 and associates to the right.</p>For example,<pre class="Agda"><a id="plfa_plfa-part1-Lists-1544" href="../Lists/#plfa_plfa-part1-Lists-1544" class="Function">_</a> <a id="plfa_plfa-part1-Lists-1546" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-1548" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-1553" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-1555" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-1557" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-1559" class="Number">0</a> <a id="plfa_plfa-part1-Lists-1561" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1563" class="Number">1</a> <a id="plfa_plfa-part1-Lists-1565" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1567" class="Number">2</a> <a id="plfa_plfa-part1-Lists-1569" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-1571" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
</pre><p>denotes the list of the first three natural numbers. Since <code>_∷_</code> associates to the right, the term parses as <code>0 ∷ (1 ∷ (2 ∷ []))</code>. Here <code>0</code> is the first element of the list, called the <em>head</em>, and <code>1 ∷ (2 ∷ [])</code> is a list of the remaining elements, called the <em>tail</em>. A list is a strange beast: it has a head and a tail, nothing in between, and the tail is itself another list!</p>As we’ve seen, parameterised types can be translated to indexed types. The definition above is equivalent to the following:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2090" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-List′"></a><a id="plfa_plfa-part1-Lists-2095" href="../Lists/#plfa_plfa-part1-Lists-2095" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2101" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2103" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2107" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2109" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-2113" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-List′.[]′"></a><a id="plfa_plfa-part1-Lists-2121" href="../Lists/#plfa_plfa-part1-Lists-2121" class="InductiveConstructor">[]′</a>  <a id="plfa_plfa-part1-Lists-2126" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2128" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2130" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2131" href="../Lists/#plfa_plfa-part1-Lists-2131" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2133" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2135" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2138" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2140" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2142" href="../Lists/#plfa_plfa-part1-Lists-2095" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2148" href="../Lists/#plfa_plfa-part1-Lists-2131" class="Bound">A</a>
  <a id="plfa_plfa-part1-Lists-List′._∷′_"></a><a id="plfa_plfa-part1-Lists-2152" href="../Lists/#plfa_plfa-part1-Lists-2152" class="InductiveConstructor Operator">_∷′_</a> <a id="plfa_plfa-part1-Lists-2157" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2159" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-2161" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2162" href="../Lists/#plfa_plfa-part1-Lists-2162" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2164" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2166" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-2169" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2171" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2173" href="../Lists/#plfa_plfa-part1-Lists-2162" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2175" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2177" href="../Lists/#plfa_plfa-part1-Lists-2095" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2183" href="../Lists/#plfa_plfa-part1-Lists-2162" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-2185" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-2187" href="../Lists/#plfa_plfa-part1-Lists-2095" class="Datatype">List′</a> <a id="plfa_plfa-part1-Lists-2193" href="../Lists/#plfa_plfa-part1-Lists-2162" class="Bound">A</a>
</pre>Each constructor takes the parameter as an implicit argument. Thus, our example list could also be written:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2315" href="../Lists/#plfa_plfa-part1-Lists-2315" class="Function">_</a> <a id="plfa_plfa-part1-Lists-2317" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-2319" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-2324" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-2326" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-2328" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2330" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2334" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2335" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2336" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2338" class="Number">0</a> <a id="plfa_plfa-part1-Lists-2340" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2341" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2345" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2346" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2347" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2349" class="Number">1</a> <a id="plfa_plfa-part1-Lists-2351" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2352" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-2356" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2357" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2358" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-2360" class="Number">2</a> <a id="plfa_plfa-part1-Lists-2362" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-2363" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-2366" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-2367" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-2368" class="Symbol">})))</a>
</pre><p>where here we have provided the implicit parameters explicitly.</p><p>Including the pragma:</p><pre><code>{-# BUILTIN LIST List #-}</code></pre><p>tells Agda that the type <code>List</code> corresponds to the Haskell type list, and the constructors <code>[]</code> and <code>_∷_</code> correspond to nil and cons respectively, allowing a more efficient representation of lists.</p><h2 id="list-syntax">List syntax</h2>We can write lists more conveniently by introducing the following definitions:<pre class="Agda"><a id="plfa_plfa-part1-Lists-2799" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_]"></a><a id="plfa_plfa-part1-Lists-2807" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[_]</a> <a id="plfa_plfa-part1-Lists-2811" href="../Lists/#plfa_plfa-part1-Lists-2815" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2813" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2815" href="../Lists/#plfa_plfa-part1-Lists-2815" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2817" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2819" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2822" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_]"></a><a id="plfa_plfa-part1-Lists-2830" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">[_,_]</a> <a id="plfa_plfa-part1-Lists-2836" href="../Lists/#plfa_plfa-part1-Lists-2842" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2838" href="../Lists/#plfa_plfa-part1-Lists-2846" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2840" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2842" href="../Lists/#plfa_plfa-part1-Lists-2842" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2844" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2846" href="../Lists/#plfa_plfa-part1-Lists-2846" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2848" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2850" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2853" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_]"></a><a id="plfa_plfa-part1-Lists-2861" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[_,_,_]</a> <a id="plfa_plfa-part1-Lists-2869" href="../Lists/#plfa_plfa-part1-Lists-2877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2871" href="../Lists/#plfa_plfa-part1-Lists-2881" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2873" href="../Lists/#plfa_plfa-part1-Lists-2885" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2875" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2877" href="../Lists/#plfa_plfa-part1-Lists-2877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2879" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2881" href="../Lists/#plfa_plfa-part1-Lists-2881" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2883" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2885" href="../Lists/#plfa_plfa-part1-Lists-2885" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2887" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2889" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2892" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-2900" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-2910" href="../Lists/#plfa_plfa-part1-Lists-2920" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-2912" href="../Lists/#plfa_plfa-part1-Lists-2924" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2914" href="../Lists/#plfa_plfa-part1-Lists-2928" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2916" href="../Lists/#plfa_plfa-part1-Lists-2932" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2918" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2920" href="../Lists/#plfa_plfa-part1-Lists-2920" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-2922" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2924" href="../Lists/#plfa_plfa-part1-Lists-2924" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2926" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2928" href="../Lists/#plfa_plfa-part1-Lists-2928" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2930" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2932" href="../Lists/#plfa_plfa-part1-Lists-2932" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2934" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2936" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2939" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-2947" href="../Lists/#plfa_plfa-part1-Lists-2947" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-2959" href="../Lists/#plfa_plfa-part1-Lists-2971" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-2961" href="../Lists/#plfa_plfa-part1-Lists-2975" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-2963" href="../Lists/#plfa_plfa-part1-Lists-2979" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2965" href="../Lists/#plfa_plfa-part1-Lists-2983" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2967" href="../Lists/#plfa_plfa-part1-Lists-2987" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2969" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-2971" href="../Lists/#plfa_plfa-part1-Lists-2971" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-2973" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2975" href="../Lists/#plfa_plfa-part1-Lists-2975" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-2977" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2979" href="../Lists/#plfa_plfa-part1-Lists-2979" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-2981" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2983" href="../Lists/#plfa_plfa-part1-Lists-2983" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-2985" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2987" href="../Lists/#plfa_plfa-part1-Lists-2987" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-2989" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-2991" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-2994" class="Keyword">pattern</a> <a id="plfa_plfa-part1-Lists-[_,_,_,_,_,_]"></a><a id="plfa_plfa-part1-Lists-3002" href="../Lists/#plfa_plfa-part1-Lists-3002" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="plfa_plfa-part1-Lists-3016" href="../Lists/#plfa_plfa-part1-Lists-3030" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3018" href="../Lists/#plfa_plfa-part1-Lists-3034" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3020" href="../Lists/#plfa_plfa-part1-Lists-3038" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3022" href="../Lists/#plfa_plfa-part1-Lists-3042" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3024" href="../Lists/#plfa_plfa-part1-Lists-3046" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3026" href="../Lists/#plfa_plfa-part1-Lists-3050" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3028" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-3030" href="../Lists/#plfa_plfa-part1-Lists-3030" class="Bound">u</a> <a id="plfa_plfa-part1-Lists-3032" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3034" href="../Lists/#plfa_plfa-part1-Lists-3034" class="Bound">v</a> <a id="plfa_plfa-part1-Lists-3036" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3038" href="../Lists/#plfa_plfa-part1-Lists-3038" class="Bound">w</a> <a id="plfa_plfa-part1-Lists-3040" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3042" href="../Lists/#plfa_plfa-part1-Lists-3042" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3044" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3046" href="../Lists/#plfa_plfa-part1-Lists-3046" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-3048" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3050" href="../Lists/#plfa_plfa-part1-Lists-3050" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-3052" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3054" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
</pre><p>This is our first use of pattern declarations. For instance, the third line tells us that <code>[ x , y , z ]</code> is equivalent to <code>x ∷ y ∷ z ∷ []</code>, and permits the former to appear either in a pattern on the left-hand side of an equation, or a term on the right-hand side of an equation.</p><h2 id="append">Append</h2><p>Our first function on lists is written <code>_++_</code> and pronounced <em>append</em>:</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-3436" class="Keyword">infixr</a> <a id="plfa_plfa-part1-Lists-3443" class="Number">5</a> <a id="plfa_plfa-part1-Lists-3445" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">_++_</a>

<a id="plfa_plfa-part1-Lists-_++_"></a><a id="plfa_plfa-part1-Lists-3451" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-3456" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3458" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-3460" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-3461" href="../Lists/#plfa_plfa-part1-Lists-3461" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3463" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-3465" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-3468" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-3470" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3472" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3477" href="../Lists/#plfa_plfa-part1-Lists-3461" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3479" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3481" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3486" href="../Lists/#plfa_plfa-part1-Lists-3461" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-3488" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-3490" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-3495" href="../Lists/#plfa_plfa-part1-Lists-3461" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-3497" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-3506" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3509" href="../Lists/#plfa_plfa-part1-Lists-3509" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-3513" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-3516" href="../Lists/#plfa_plfa-part1-Lists-3509" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-3519" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3520" href="../Lists/#plfa_plfa-part1-Lists-3520" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3522" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3524" href="../Lists/#plfa_plfa-part1-Lists-3524" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-3526" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-3528" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3531" href="../Lists/#plfa_plfa-part1-Lists-3531" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-3535" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-3538" href="../Lists/#plfa_plfa-part1-Lists-3520" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-3540" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-3542" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-3543" href="../Lists/#plfa_plfa-part1-Lists-3524" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-3546" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-3549" href="../Lists/#plfa_plfa-part1-Lists-3531" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-3551" class="Symbol">)</a>
</pre><p>The type <code>A</code> is an implicit argument to append, making it a <em>polymorphic</em> function (one that can be used at many types). A list appended to the empty list yields the list itself. A list appended to a non-empty list yields a list with the head the same as the head of the non-empty list, and a tail the same as the other list appended to tail of the non-empty list.</p>Here is an example, showing how to compute the result of appending two lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-4009" href="../Lists/#plfa_plfa-part1-Lists-4009" class="Function">_</a> <a id="plfa_plfa-part1-Lists-4011" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4013" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4015" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4017" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4019" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4021" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4023" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4025" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-4027" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4030" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4032" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4034" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4036" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4038" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-4040" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-4042" href="../Lists/#plfa_plfa-part1-Lists-2947" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-4044" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4046" href="../Lists/#plfa_plfa-part1-Lists-2947" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4048" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4050" href="../Lists/#plfa_plfa-part1-Lists-2947" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4052" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4054" href="../Lists/#plfa_plfa-part1-Lists-2947" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4056" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4058" href="../Lists/#plfa_plfa-part1-Lists-2947" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-4060" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4062" href="../Lists/#plfa_plfa-part1-Lists-2947" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-4064" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-4066" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4070" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4080" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4082" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4084" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4086" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4088" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4090" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4092" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4095" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4098" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4100" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4102" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4104" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4106" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-4111" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4119" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4121" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4123" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4124" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4126" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4128" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4130" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4132" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4135" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4138" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4140" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4142" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4144" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4146" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4148" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4152" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4160" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4162" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4164" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4166" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4168" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4169" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4171" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4173" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4176" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4179" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4181" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4183" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4185" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4187" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4189" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4193" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4201" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4203" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4205" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4207" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4209" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4211" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4213" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4214" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4217" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4220" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4222" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4224" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4226" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4228" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-4230" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4234" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4242" class="Number">0</a> <a id="plfa_plfa-part1-Lists-4244" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4246" class="Number">1</a> <a id="plfa_plfa-part1-Lists-4248" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4250" class="Number">2</a> <a id="plfa_plfa-part1-Lists-4252" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4254" class="Number">3</a> <a id="plfa_plfa-part1-Lists-4256" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4258" class="Number">4</a> <a id="plfa_plfa-part1-Lists-4260" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4262" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-4267" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>Appending two lists requires time linear in the number of elements in the first list.</p><h2 id="reasoning-about-append">Reasoning about append</h2>We can reason about lists in much the same way that we reason about numbers. Here is the proof that append is associative:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-assoc"></a><a id="plfa_plfa-part1-Lists-4520" href="../Lists/#plfa_plfa-part1-Lists-4520" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4529" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4531" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-4533" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-4534" href="../Lists/#plfa_plfa-part1-Lists-4534" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-4536" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4538" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-4541" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-4543" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4544" href="../Lists/#plfa_plfa-part1-Lists-4544" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4547" href="../Lists/#plfa_plfa-part1-Lists-4547" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4550" href="../Lists/#plfa_plfa-part1-Lists-4550" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4553" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-4555" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-4560" href="../Lists/#plfa_plfa-part1-Lists-4534" class="Bound">A</a><a id="plfa_plfa-part1-Lists-4561" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4565" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-4567" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4568" href="../Lists/#plfa_plfa-part1-Lists-4544" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4571" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4574" href="../Lists/#plfa_plfa-part1-Lists-4547" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4576" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4578" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4581" href="../Lists/#plfa_plfa-part1-Lists-4550" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4584" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-4586" href="../Lists/#plfa_plfa-part1-Lists-4544" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4589" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4592" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4593" href="../Lists/#plfa_plfa-part1-Lists-4547" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4596" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4599" href="../Lists/#plfa_plfa-part1-Lists-4550" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4601" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-4603" href="../Lists/#plfa_plfa-part1-Lists-4520" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4612" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4615" href="../Lists/#plfa_plfa-part1-Lists-4615" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4618" href="../Lists/#plfa_plfa-part1-Lists-4618" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4621" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4625" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4635" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4636" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4639" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4642" href="../Lists/#plfa_plfa-part1-Lists-4615" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4644" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4646" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4649" href="../Lists/#plfa_plfa-part1-Lists-4618" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4654" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4662" href="../Lists/#plfa_plfa-part1-Lists-4615" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4665" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4668" href="../Lists/#plfa_plfa-part1-Lists-4618" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4673" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4681" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-4684" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4687" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4688" href="../Lists/#plfa_plfa-part1-Lists-4615" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4691" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4694" href="../Lists/#plfa_plfa-part1-Lists-4618" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4696" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4700" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-4702" href="../Lists/#plfa_plfa-part1-Lists-4520" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4711" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4712" href="../Lists/#plfa_plfa-part1-Lists-4712" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4714" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4716" href="../Lists/#plfa_plfa-part1-Lists-4716" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-4718" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4720" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4723" href="../Lists/#plfa_plfa-part1-Lists-4723" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-4726" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-4730" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-4740" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4741" href="../Lists/#plfa_plfa-part1-Lists-4712" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4743" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4745" href="../Lists/#plfa_plfa-part1-Lists-4716" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4748" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4751" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4753" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4755" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4758" href="../Lists/#plfa_plfa-part1-Lists-4723" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4763" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4771" href="../Lists/#plfa_plfa-part1-Lists-4712" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4773" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4775" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4776" href="../Lists/#plfa_plfa-part1-Lists-4716" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4779" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4782" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4784" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4786" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4789" href="../Lists/#plfa_plfa-part1-Lists-4723" class="Bound">zs</a>
  <a id="plfa_plfa-part1-Lists-4794" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4802" href="../Lists/#plfa_plfa-part1-Lists-4712" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4804" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4806" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-4808" href="../Lists/#plfa_plfa-part1-Lists-4716" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4811" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4814" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-4816" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4818" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4821" href="../Lists/#plfa_plfa-part1-Lists-4723" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4823" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4827" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-4830" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1139" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-4835" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4836" href="../Lists/#plfa_plfa-part1-Lists-4712" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4838" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-4840" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4842" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4843" href="../Lists/#plfa_plfa-part1-Lists-4520" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-4852" href="../Lists/#plfa_plfa-part1-Lists-4716" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4855" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4858" href="../Lists/#plfa_plfa-part1-Lists-4723" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4860" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-4862" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-4868" href="../Lists/#plfa_plfa-part1-Lists-4712" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4870" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4872" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4873" href="../Lists/#plfa_plfa-part1-Lists-4716" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4876" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4879" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4880" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4883" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4886" href="../Lists/#plfa_plfa-part1-Lists-4723" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4888" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-4893" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-4901" href="../Lists/#plfa_plfa-part1-Lists-4712" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-4903" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-4905" href="../Lists/#plfa_plfa-part1-Lists-4716" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-4908" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4911" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-4912" href="../Lists/#plfa_plfa-part1-Lists-4720" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-4915" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-4918" href="../Lists/#plfa_plfa-part1-Lists-4723" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-4920" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-4924" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>++-assoc xs ys zs</code>.</p><p>Recall that Agda supports <a href="../Induction/#sections">sections</a>. Applying <code>cong (x ∷_)</code> promotes the inductive hypothesis:</p><pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre><p>to the equality:</p><pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre><p>which is needed in the proof.</p>It is also easy to show that <code>[]</code> is a left and right identity for <code>_++_</code>. That it is a left identity is immediate from the definition:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityˡ"></a><a id="plfa_plfa-part1-Lists-5717" href="../Lists/#plfa_plfa-part1-Lists-5717" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-5730" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5732" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5734" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5735" href="../Lists/#plfa_plfa-part1-Lists-5735" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5737" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5739" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5742" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5744" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5745" href="../Lists/#plfa_plfa-part1-Lists-5745" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5748" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5750" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5755" href="../Lists/#plfa_plfa-part1-Lists-5735" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5756" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5758" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5760" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5763" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5766" href="../Lists/#plfa_plfa-part1-Lists-5745" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5769" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5771" href="../Lists/#plfa_plfa-part1-Lists-5745" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-5774" href="../Lists/#plfa_plfa-part1-Lists-5717" class="Function">++-identityˡ</a> <a id="plfa_plfa-part1-Lists-5787" href="../Lists/#plfa_plfa-part1-Lists-5787" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5790" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5794" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5804" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5807" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5810" href="../Lists/#plfa_plfa-part1-Lists-5787" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-5815" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-5823" href="../Lists/#plfa_plfa-part1-Lists-5787" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-5828" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre>That it is a right identity follows by simple induction:<pre class="Agda"><a id="plfa_plfa-part1-Lists-++-identityʳ"></a><a id="plfa_plfa-part1-Lists-5899" href="../Lists/#plfa_plfa-part1-Lists-5899" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-5912" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5914" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-5916" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-5917" href="../Lists/#plfa_plfa-part1-Lists-5917" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-5919" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5921" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-5924" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-5926" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-5927" href="../Lists/#plfa_plfa-part1-Lists-5927" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5930" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-5932" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-5937" href="../Lists/#plfa_plfa-part1-Lists-5917" class="Bound">A</a><a id="plfa_plfa-part1-Lists-5938" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-5940" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-5942" href="../Lists/#plfa_plfa-part1-Lists-5927" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-5945" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5948" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5951" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-5953" href="../Lists/#plfa_plfa-part1-Lists-5927" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-5956" href="../Lists/#plfa_plfa-part1-Lists-5899" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-5969" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5972" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-5976" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-5986" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-5989" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-5992" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-5997" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6005" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6010" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-6012" href="../Lists/#plfa_plfa-part1-Lists-5899" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6025" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6026" href="../Lists/#plfa_plfa-part1-Lists-6026" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6028" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6030" href="../Lists/#plfa_plfa-part1-Lists-6030" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6032" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6034" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6038" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6048" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6049" href="../Lists/#plfa_plfa-part1-Lists-6026" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6051" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6053" href="../Lists/#plfa_plfa-part1-Lists-6030" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6055" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6057" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6060" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-6065" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6073" href="../Lists/#plfa_plfa-part1-Lists-6026" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6075" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6077" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6078" href="../Lists/#plfa_plfa-part1-Lists-6030" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-6081" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-6084" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6086" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6090" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-6093" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1139" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-6098" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6099" href="../Lists/#plfa_plfa-part1-Lists-6026" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6101" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷_</a><a id="plfa_plfa-part1-Lists-6103" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6105" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6106" href="../Lists/#plfa_plfa-part1-Lists-5899" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-6119" href="../Lists/#plfa_plfa-part1-Lists-6030" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6121" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-6123" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-6129" href="../Lists/#plfa_plfa-part1-Lists-6026" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6131" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6133" href="../Lists/#plfa_plfa-part1-Lists-6030" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-6138" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>As we will see later, these three properties establish that <code>_++_</code> and <code>[]</code> form a <em>monoid</em> over lists.</p><h2 id="length">Length</h2>Our next function finds the length of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-length"></a><a id="plfa_plfa-part1-Lists-6314" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6321" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6323" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-6325" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6326" href="../Lists/#plfa_plfa-part1-Lists-6326" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6328" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6330" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-6333" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6335" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6337" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-6342" href="../Lists/#plfa_plfa-part1-Lists-6326" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-6344" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-6346" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-6348" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6355" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-6365" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-6368" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
<a id="plfa_plfa-part1-Lists-6373" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6380" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6381" href="../Lists/#plfa_plfa-part1-Lists-6381" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-6383" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6385" href="../Lists/#plfa_plfa-part1-Lists-6385" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6387" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-6390" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-6393" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6397" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6398" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6405" href="../Lists/#plfa_plfa-part1-Lists-6385" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-6407" class="Symbol">)</a>
</pre><p>Again, it takes an implicit parameter <code>A</code>. The length of the empty list is zero. The length of a non-empty list is one greater than the length of the tail of the list.</p>Here is an example showing how to compute the length of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-6654" href="../Lists/#plfa_plfa-part1-Lists-6654" class="Function">_</a> <a id="plfa_plfa-part1-Lists-6656" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-6658" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6665" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-6667" class="Number">0</a> <a id="plfa_plfa-part1-Lists-6669" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-6671" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6673" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-6675" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6677" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-6679" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-6681" class="Number">3</a>
<a id="plfa_plfa-part1-Lists-6683" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-6685" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-6689" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-6699" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6706" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6707" class="Number">0</a> <a id="plfa_plfa-part1-Lists-6709" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6711" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6713" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6715" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6717" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6719" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6721" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-6725" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6733" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6737" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6738" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6745" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6746" class="Number">1</a> <a id="plfa_plfa-part1-Lists-6748" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6750" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6752" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6754" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6756" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6761" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6769" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6773" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6774" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6778" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6779" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6786" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6787" class="Number">2</a> <a id="plfa_plfa-part1-Lists-6789" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-6791" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6793" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-6799" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6807" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6811" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6812" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6816" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6817" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6821" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6822" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-6829" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-6830" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="plfa_plfa-part1-Lists-6831" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-6833" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-6835" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-6841" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-6849" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6853" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6854" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6858" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-6859" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-6863" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="plfa_plfa-part1-Lists-6867" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-6872" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>Computing the length of a list requires time linear in the number of elements in the list.</p><p>In the second-to-last line, we cannot write simply <code>length []</code> but must instead write <code>length {ℕ} []</code>. Since <code>[]</code> has no elements, Agda has insufficient information to infer the implicit parameter.</p><h2 id="reasoning-about-length">Reasoning about length</h2>The length of one list appended to another is the sum of the lengths of the lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-length-++"></a><a id="plfa_plfa-part1-Lists-7289" href="../Lists/#plfa_plfa-part1-Lists-7289" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7299" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7301" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-7303" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7304" href="../Lists/#plfa_plfa-part1-Lists-7304" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-7306" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7308" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-7311" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7313" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7314" href="../Lists/#plfa_plfa-part1-Lists-7314" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7317" href="../Lists/#plfa_plfa-part1-Lists-7317" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7320" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-7322" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-7327" href="../Lists/#plfa_plfa-part1-Lists-7304" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7328" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7332" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-7334" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7341" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7342" href="../Lists/#plfa_plfa-part1-Lists-7314" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7345" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7348" href="../Lists/#plfa_plfa-part1-Lists-7317" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7350" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7352" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-7354" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7361" href="../Lists/#plfa_plfa-part1-Lists-7314" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7364" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7366" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7373" href="../Lists/#plfa_plfa-part1-Lists-7317" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-7376" href="../Lists/#plfa_plfa-part1-Lists-7289" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7386" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7387" href="../Lists/#plfa_plfa-part1-Lists-7387" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7388" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7390" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7393" href="../Lists/#plfa_plfa-part1-Lists-7393" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7396" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7400" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7410" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7417" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7418" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7421" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7424" href="../Lists/#plfa_plfa-part1-Lists-7393" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7426" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7430" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7438" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7445" href="../Lists/#plfa_plfa-part1-Lists-7393" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7450" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7458" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7465" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-7466" href="../Lists/#plfa_plfa-part1-Lists-7387" class="Bound">A</a><a id="plfa_plfa-part1-Lists-7467" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-7469" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-7472" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7474" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7481" href="../Lists/#plfa_plfa-part1-Lists-7393" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7486" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-7488" href="../Lists/#plfa_plfa-part1-Lists-7289" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7498" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7499" href="../Lists/#plfa_plfa-part1-Lists-7499" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7501" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7503" href="../Lists/#plfa_plfa-part1-Lists-7503" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7505" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7507" href="../Lists/#plfa_plfa-part1-Lists-7507" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-7510" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-7514" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-7524" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7531" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-7533" href="../Lists/#plfa_plfa-part1-Lists-7499" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7535" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7537" href="../Lists/#plfa_plfa-part1-Lists-7503" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7539" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7541" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7544" href="../Lists/#plfa_plfa-part1-Lists-7507" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7546" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7550" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7558" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7562" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7563" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7570" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7571" href="../Lists/#plfa_plfa-part1-Lists-7503" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7574" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-7577" href="../Lists/#plfa_plfa-part1-Lists-7507" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7579" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-7584" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-7587" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1139" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-7592" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7596" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7597" href="../Lists/#plfa_plfa-part1-Lists-7289" class="Function">length-++</a> <a id="plfa_plfa-part1-Lists-7607" href="../Lists/#plfa_plfa-part1-Lists-7503" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7610" href="../Lists/#plfa_plfa-part1-Lists-7507" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7612" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7614" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-7620" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-7624" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7625" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7632" href="../Lists/#plfa_plfa-part1-Lists-7503" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-7635" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7637" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7644" href="../Lists/#plfa_plfa-part1-Lists-7507" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-7646" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-7650" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-7658" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7665" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-7666" href="../Lists/#plfa_plfa-part1-Lists-7499" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-7668" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-7670" href="../Lists/#plfa_plfa-part1-Lists-7503" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-7672" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-7674" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-7676" href="../Lists/#plfa_plfa-part1-Lists-6314" class="Function">length</a> <a id="plfa_plfa-part1-Lists-7683" href="../Lists/#plfa_plfa-part1-Lists-7507" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-7688" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. As before, Agda cannot infer the implicit type parameter to <code>length</code>, and it must be given explicitly. The inductive case instantiates to <code>x ∷ xs</code>, and follows by straightforward computation combined with the inductive hypothesis. As usual, the inductive hypothesis is indicated by a recursive invocation of the proof, in this case <code>length-++ xs ys</code>, and it is promoted by the congruence <code>cong suc</code>.</p><h2 id="reverse">Reverse</h2>Using append, it is easy to formulate a function to reverse a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse"></a><a id="plfa_plfa-part1-Lists-8316" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8324" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8326" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-8328" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-8329" href="../Lists/#plfa_plfa-part1-Lists-8329" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8331" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8333" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-8336" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-8338" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8340" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8345" href="../Lists/#plfa_plfa-part1-Lists-8329" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-8347" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-8349" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-8354" href="../Lists/#plfa_plfa-part1-Lists-8329" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-8356" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8364" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-8374" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8377" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-8380" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8388" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8389" href="../Lists/#plfa_plfa-part1-Lists-8389" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8391" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8393" href="../Lists/#plfa_plfa-part1-Lists-8393" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-8395" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-8398" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-8401" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8409" href="../Lists/#plfa_plfa-part1-Lists-8393" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-8412" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8415" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8417" href="../Lists/#plfa_plfa-part1-Lists-8389" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-8419" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a>
</pre><p>The reverse of the empty list is the empty list. The reverse of a non-empty list is the reverse of its tail appended to a unit list containing its head.</p>Here is an example showing how to reverse a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-8637" href="../Lists/#plfa_plfa-part1-Lists-8637" class="Function">_</a> <a id="plfa_plfa-part1-Lists-8639" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-8641" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8649" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8651" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8653" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8655" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8657" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8659" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8661" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-8663" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-8665" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8667" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8669" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8671" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8673" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-8675" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8677" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-8679" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-8681" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-8685" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-8695" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8703" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8704" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8706" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8708" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8710" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8712" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8714" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8716" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8718" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-8722" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8730" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8738" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8739" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8741" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8743" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8745" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8747" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8749" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8751" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8754" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8756" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8758" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8762" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8770" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8771" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8779" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8780" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8782" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8784" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8786" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8788" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8791" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8793" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8795" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8796" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8798" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8801" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8803" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8805" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8809" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8817" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-8819" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-8827" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8830" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8833" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8835" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8837" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8838" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8840" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8843" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8845" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8847" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8848" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8850" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8853" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8855" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8857" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8861" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8869" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-8871" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8874" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8877" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8879" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8881" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8882" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8884" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8887" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8889" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8891" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-8892" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8894" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8897" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-8899" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8901" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-8905" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8913" class="Symbol">((</a><a id="plfa_plfa-part1-Lists-8915" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8918" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8921" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8923" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8925" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8927" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8929" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8932" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8934" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8936" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8938" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8940" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8943" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8945" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8947" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-8952" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8960" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-8961" class="Number">2</a> <a id="plfa_plfa-part1-Lists-8963" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8965" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-8968" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8971" class="Number">1</a> <a id="plfa_plfa-part1-Lists-8973" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8975" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-8977" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-8979" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-8982" class="Number">0</a> <a id="plfa_plfa-part1-Lists-8984" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-8986" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-8991" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-8999" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9001" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9003" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9004" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9007" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9010" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9012" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9014" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9016" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9018" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9021" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9023" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9025" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9030" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9038" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9039" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9041" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9043" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9045" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9047" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9049" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-9051" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9054" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9056" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9058" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9063" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9071" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9073" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9075" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9076" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9078" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9080" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9083" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9086" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9088" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9090" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9092" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9096" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9104" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9106" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9108" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9110" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9112" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-9113" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-9116" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-9119" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9121" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9123" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-9125" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-9129" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9137" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9139" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9141" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9143" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9145" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9147" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-9149" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-9154" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-9162" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-9164" class="Number">2</a> <a id="plfa_plfa-part1-Lists-9166" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-9168" class="Number">1</a> <a id="plfa_plfa-part1-Lists-9170" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-9172" class="Number">0</a> <a id="plfa_plfa-part1-Lists-9174" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-9178" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>Reversing a list in this way takes time <em>quadratic</em> in the length of the list. This is because reverse ends up appending lists of lengths <code>1</code>, <code>2</code>, up to <code>n - 1</code>, where <code>n</code> is the length of the list being reversed, append takes time linear in the length of the first list, and the sum of the numbers up to <code>n - 1</code> is <code>n * (n - 1) / 2</code>. (We will validate that last fact in an exercise later in this chapter.)</p><h4 id="exercise-reverse--distrib-recommended">Exercise <code>reverse-++-distrib</code> (recommended)</h4><p>Show that the reverse of one list appended to another is the reverse of the second appended to the reverse of the first:</p><pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-9824" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-reverse-involutive-recommended">Exercise <code>reverse-involutive</code> (recommended)</h4><p>A function is an <em>involution</em> if when applied twice it acts as the identity function. Show that reverse is an involution:</p><pre><code>reverse (reverse xs) ≡ xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-10066" class="Comment">-- Your code goes here</a>
</pre><h2 id="faster-reverse">Faster reverse</h2>The definition above, while easy to reason about, is less efficient than one might expect since it takes time quadratic in the length of the list. The idea is that we generalise reverse to take an additional argument:<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt"></a><a id="plfa_plfa-part1-Lists-10340" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10346" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10348" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10350" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10351" href="../Lists/#plfa_plfa-part1-Lists-10351" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10353" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10355" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10358" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10360" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10362" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10367" href="../Lists/#plfa_plfa-part1-Lists-10351" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10369" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10371" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10376" href="../Lists/#plfa_plfa-part1-Lists-10351" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10378" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10380" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10385" href="../Lists/#plfa_plfa-part1-Lists-10351" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-10387" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10393" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>       <a id="plfa_plfa-part1-Lists-10402" href="../Lists/#plfa_plfa-part1-Lists-10402" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-10406" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10409" href="../Lists/#plfa_plfa-part1-Lists-10402" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-10412" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10418" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10419" href="../Lists/#plfa_plfa-part1-Lists-10419" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10421" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10423" href="../Lists/#plfa_plfa-part1-Lists-10423" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10425" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10427" href="../Lists/#plfa_plfa-part1-Lists-10427" class="Bound">ys</a>  <a id="plfa_plfa-part1-Lists-10431" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-10434" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10440" href="../Lists/#plfa_plfa-part1-Lists-10423" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10443" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10444" href="../Lists/#plfa_plfa-part1-Lists-10419" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10446" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10448" href="../Lists/#plfa_plfa-part1-Lists-10427" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10450" class="Symbol">)</a>
</pre><p>The definition is by recursion on the first argument. The second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we recurse becomes <em>smaller</em>.</p>Shunt is related to reverse as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-shunt-reverse"></a><a id="plfa_plfa-part1-Lists-10692" href="../Lists/#plfa_plfa-part1-Lists-10692" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10706" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10708" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-10710" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-10711" href="../Lists/#plfa_plfa-part1-Lists-10711" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-10713" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10715" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-10718" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-10720" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10721" href="../Lists/#plfa_plfa-part1-Lists-10721" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10724" href="../Lists/#plfa_plfa-part1-Lists-10724" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10727" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-10729" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-10734" href="../Lists/#plfa_plfa-part1-Lists-10711" class="Bound">A</a><a id="plfa_plfa-part1-Lists-10735" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-10739" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-10741" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10747" href="../Lists/#plfa_plfa-part1-Lists-10721" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10750" href="../Lists/#plfa_plfa-part1-Lists-10724" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10753" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-10755" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10763" href="../Lists/#plfa_plfa-part1-Lists-10721" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10766" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10769" href="../Lists/#plfa_plfa-part1-Lists-10724" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-10772" href="../Lists/#plfa_plfa-part1-Lists-10692" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10786" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10789" href="../Lists/#plfa_plfa-part1-Lists-10789" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10792" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-10796" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-10806" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10812" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10815" href="../Lists/#plfa_plfa-part1-Lists-10789" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10820" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-10828" href="../Lists/#plfa_plfa-part1-Lists-10789" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10833" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-10841" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10849" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-10852" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10855" href="../Lists/#plfa_plfa-part1-Lists-10789" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10860" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-10862" href="../Lists/#plfa_plfa-part1-Lists-10692" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10876" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10877" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10879" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10881" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10883" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10885" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-10888" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-10892" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-10902" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10908" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10909" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10911" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10913" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-10915" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10917" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-10922" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-10930" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-10936" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10939" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10940" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10942" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10944" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10946" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-10950" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-10953" href="../Lists/#plfa_plfa-part1-Lists-10692" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-10967" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10970" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-10971" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-10973" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-10975" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-10977" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-10979" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-10985" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-10993" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-10996" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-10999" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11000" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11002" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11004" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11006" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11010" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11018" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11026" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11029" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11032" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11033" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11035" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11037" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11039" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11042" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11044" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-11048" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-11051" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-11055" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11056" href="../Lists/#plfa_plfa-part1-Lists-4520" class="Function">++-assoc</a> <a id="plfa_plfa-part1-Lists-11065" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11066" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11074" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11076" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11078" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11080" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11082" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-11084" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-11086" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11088" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-11094" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11095" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11103" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11106" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11109" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-11111" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11113" href="../Lists/#plfa_plfa-part1-Lists-2807" class="InductiveConstructor Operator">]</a><a id="plfa_plfa-part1-Lists-11114" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11116" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11119" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11124" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-11132" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-11140" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-11141" href="../Lists/#plfa_plfa-part1-Lists-10877" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-11143" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-11145" href="../Lists/#plfa_plfa-part1-Lists-10881" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-11147" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-11149" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-11152" href="../Lists/#plfa_plfa-part1-Lists-10885" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-11157" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>The proof is by induction on the first argument. The base case instantiates to <code>[]</code>, and follows by straightforward computation. The inductive case instantiates to <code>x ∷ xs</code> and follows by the inductive hypothesis and associativity of append. When we invoke the inductive hypothesis, the second argument actually becomes <em>larger</em>, but this is not a problem because the argument on which we induct becomes <em>smaller</em>.</p><p>Generalising on an auxiliary argument, which becomes larger as the argument on which we recurse or induct becomes smaller, is a common trick. It belongs in your quiver of arrows, ready to slay the right problem.</p>Having defined shunt by generalisation, it is now easy to respecialise to give a more efficient definition of reverse:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverse′"></a><a id="plfa_plfa-part1-Lists-11920" href="../Lists/#plfa_plfa-part1-Lists-11920" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-11929" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11931" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-11933" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-11934" href="../Lists/#plfa_plfa-part1-Lists-11934" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-11936" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-11938" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-11941" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-11943" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-11945" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-11950" href="../Lists/#plfa_plfa-part1-Lists-11934" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-11952" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-11954" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-11959" href="../Lists/#plfa_plfa-part1-Lists-11934" class="Bound">A</a>
<a id="plfa_plfa-part1-Lists-11961" href="../Lists/#plfa_plfa-part1-Lists-11920" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-11970" href="../Lists/#plfa_plfa-part1-Lists-11970" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11973" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-11975" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-11981" href="../Lists/#plfa_plfa-part1-Lists-11970" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-11984" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
</pre>Given our previous lemma, it is straightforward to show the two definitions equivalent:<pre class="Agda"><a id="plfa_plfa-part1-Lists-reverses"></a><a id="plfa_plfa-part1-Lists-12088" href="../Lists/#plfa_plfa-part1-Lists-12088" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-12097" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12099" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-12101" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-12102" href="../Lists/#plfa_plfa-part1-Lists-12102" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12104" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12106" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-12109" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-12111" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12112" href="../Lists/#plfa_plfa-part1-Lists-12112" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12115" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12117" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-12122" href="../Lists/#plfa_plfa-part1-Lists-12102" class="Bound">A</a><a id="plfa_plfa-part1-Lists-12123" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12127" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12129" href="../Lists/#plfa_plfa-part1-Lists-11920" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12138" href="../Lists/#plfa_plfa-part1-Lists-12112" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12141" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-12143" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12151" href="../Lists/#plfa_plfa-part1-Lists-12112" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-12154" href="../Lists/#plfa_plfa-part1-Lists-12088" class="Function">reverses</a> <a id="plfa_plfa-part1-Lists-12163" href="../Lists/#plfa_plfa-part1-Lists-12163" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12166" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-12170" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-12180" href="../Lists/#plfa_plfa-part1-Lists-11920" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12189" href="../Lists/#plfa_plfa-part1-Lists-12163" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-12194" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12202" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12208" href="../Lists/#plfa_plfa-part1-Lists-12163" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12211" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12216" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-12219" href="../Lists/#plfa_plfa-part1-Lists-10692" class="Function">shunt-reverse</a> <a id="plfa_plfa-part1-Lists-12233" href="../Lists/#plfa_plfa-part1-Lists-12163" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12236" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-12239" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-12245" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12253" href="../Lists/#plfa_plfa-part1-Lists-12163" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-12256" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-12259" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12264" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-12267" href="../Lists/#plfa_plfa-part1-Lists-5899" class="Function">++-identityʳ</a> <a id="plfa_plfa-part1-Lists-12280" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12281" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12289" href="../Lists/#plfa_plfa-part1-Lists-12163" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-12291" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12293" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-12299" href="../Lists/#plfa_plfa-part1-Lists-8316" class="Function">reverse</a> <a id="plfa_plfa-part1-Lists-12307" href="../Lists/#plfa_plfa-part1-Lists-12163" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-12312" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre>Here is an example showing fast reverse of the list <code>[ 0 , 1 , 2 ]</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-12396" href="../Lists/#plfa_plfa-part1-Lists-12396" class="Function">_</a> <a id="plfa_plfa-part1-Lists-12398" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12400" href="../Lists/#plfa_plfa-part1-Lists-11920" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12409" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-12411" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12413" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12415" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12417" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12419" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12421" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-12423" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-12425" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-12427" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12429" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12431" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12433" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-12435" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12437" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-12439" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-12441" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-12445" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-12455" href="../Lists/#plfa_plfa-part1-Lists-11920" class="Function">reverse′</a> <a id="plfa_plfa-part1-Lists-12464" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12465" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12467" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12469" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12471" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12473" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12475" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12477" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12479" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12483" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12491" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12497" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12498" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12500" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12502" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12504" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12506" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12508" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12510" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12512" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12514" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12519" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12527" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12533" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12534" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12536" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12538" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12540" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12542" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12544" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12546" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12547" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12549" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12551" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12553" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12557" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12565" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12571" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12572" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12574" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12576" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12578" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12580" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12581" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12583" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12585" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12587" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12589" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12591" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12595" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12603" href="../Lists/#plfa_plfa-part1-Lists-10340" class="Function">shunt</a> <a id="plfa_plfa-part1-Lists-12609" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-12612" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12613" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12615" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12617" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12619" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12621" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12623" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12625" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-12627" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-12631" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-12639" class="Number">2</a> <a id="plfa_plfa-part1-Lists-12641" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12643" class="Number">1</a> <a id="plfa_plfa-part1-Lists-12645" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12647" class="Number">0</a> <a id="plfa_plfa-part1-Lists-12649" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-12651" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-12656" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>Now the time to reverse a list is linear in the length of the list.</p><h2 id="Map">Map</h2>Map applies a function to every element of a list to generate a corresponding list. Map is an example of a <em>higher-order function</em>, one which takes a function as an argument or returns a function as a result:<pre class="Agda"><a id="plfa_plfa-part1-Lists-map"></a><a id="plfa_plfa-part1-Lists-12963" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-12967" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12969" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-12971" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-12972" href="../Lists/#plfa_plfa-part1-Lists-12972" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12974" href="../Lists/#plfa_plfa-part1-Lists-12974" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-12976" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-12978" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-12981" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-12983" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12985" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-12986" href="../Lists/#plfa_plfa-part1-Lists-12972" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-12988" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12990" href="../Lists/#plfa_plfa-part1-Lists-12974" class="Bound">B</a><a id="plfa_plfa-part1-Lists-12991" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-12993" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-12995" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13000" href="../Lists/#plfa_plfa-part1-Lists-12972" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-13002" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13004" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13009" href="../Lists/#plfa_plfa-part1-Lists-12974" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-13011" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13015" href="../Lists/#plfa_plfa-part1-Lists-13015" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13017" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-13027" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13030" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-13033" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13037" href="../Lists/#plfa_plfa-part1-Lists-13037" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13039" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13040" href="../Lists/#plfa_plfa-part1-Lists-13040" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13042" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13044" href="../Lists/#plfa_plfa-part1-Lists-13044" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-13046" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-13049" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-13052" href="../Lists/#plfa_plfa-part1-Lists-13037" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13054" href="../Lists/#plfa_plfa-part1-Lists-13040" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-13056" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13058" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13062" href="../Lists/#plfa_plfa-part1-Lists-13037" class="Bound">f</a> <a id="plfa_plfa-part1-Lists-13064" href="../Lists/#plfa_plfa-part1-Lists-13044" class="Bound">xs</a>
</pre><p>Map of the empty list is the empty list. Map of a non-empty list yields a list with head the same as the function applied to the head of the given list, and tail the same as map of the function applied to the tail of the given list.</p>Here is an example showing how to use map to increment every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-13393" href="../Lists/#plfa_plfa-part1-Lists-13393" class="Function">_</a> <a id="plfa_plfa-part1-Lists-13395" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13397" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13401" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13405" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13407" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13409" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13411" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13413" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13415" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13417" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13419" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13421" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13423" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13425" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13427" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13429" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13431" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13433" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-13435" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-13437" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13441" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13451" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13455" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13459" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13460" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13462" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13464" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13466" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13468" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13470" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13472" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13474" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13478" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13486" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13490" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13492" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13494" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13498" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13502" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13503" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13505" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13507" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13509" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13511" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13513" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13517" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13525" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13529" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13531" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13533" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13537" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13539" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13541" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13545" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13549" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-13550" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13552" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13554" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-13556" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-13560" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13568" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13572" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13574" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13576" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13580" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13582" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13584" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13588" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13590" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13592" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13596" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13600" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13605" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13613" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13617" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13619" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13621" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13625" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13627" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13629" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-13633" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13635" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13637" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13642" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-13650" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13652" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13654" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13656" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13658" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13660" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-13662" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-13667" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>Map requires time linear in the length of the list.</p>It is often convenient to exploit currying by applying map to a function to yield a new function, and at a later point applying the resulting function:<pre class="Agda"><a id="plfa_plfa-part1-Lists-sucs"></a><a id="plfa_plfa-part1-Lists-13886" href="../Lists/#plfa_plfa-part1-Lists-13886" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-13891" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13893" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13898" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-13900" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-13902" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-13907" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-13909" href="../Lists/#plfa_plfa-part1-Lists-13886" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-13914" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-13916" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-13920" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a>

<a id="plfa_plfa-part1-Lists-13925" href="../Lists/#plfa_plfa-part1-Lists-13925" class="Function">_</a> <a id="plfa_plfa-part1-Lists-13927" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-13929" href="../Lists/#plfa_plfa-part1-Lists-13886" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-13934" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13936" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13938" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13940" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13942" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13944" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13946" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-13948" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-13950" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13952" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13954" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13956" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13958" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13960" class="Number">3</a> <a id="plfa_plfa-part1-Lists-13962" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-13964" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-13966" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-13970" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-13980" href="../Lists/#plfa_plfa-part1-Lists-13886" class="Function">sucs</a> <a id="plfa_plfa-part1-Lists-13985" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-13987" class="Number">0</a> <a id="plfa_plfa-part1-Lists-13989" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13991" class="Number">1</a> <a id="plfa_plfa-part1-Lists-13993" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-13995" class="Number">2</a> <a id="plfa_plfa-part1-Lists-13997" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14001" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14009" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-14013" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-14017" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14019" class="Number">0</a> <a id="plfa_plfa-part1-Lists-14021" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14023" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14025" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14027" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14029" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14033" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-14041" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-14043" class="Number">1</a> <a id="plfa_plfa-part1-Lists-14045" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14047" class="Number">2</a> <a id="plfa_plfa-part1-Lists-14049" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-14051" class="Number">3</a> <a id="plfa_plfa-part1-Lists-14053" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-14057" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>A type that is parameterised on another type, such as list, often has a corresponding map, which accepts a function and returns a function from the type parameterised on the domain of the function to the type parameterised on the range of the function. Further, a type that is parameterised on <em>n</em> types often has a map that is parameterised on <em>n</em> functions.</p><h4 id="exercise-map-compose-practice">Exercise <code>map-compose</code> (practice)</h4><p>Prove that the map of a composition is equal to the composition of two maps:</p><pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre><p>The last step of the proof requires extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-14638" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map--distribute-practice">Exercise <code>map-++-distribute</code> (practice)</h4><p>Prove the following relationship between map and append:</p><pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-14823" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-tree-practice">Exercise <code>map-Tree</code> (practice)</h4>Define a type of trees with leaves of type <code>A</code> and internal nodes of type <code>B</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-14975" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Tree"></a><a id="plfa_plfa-part1-Lists-14980" href="../Lists/#plfa_plfa-part1-Lists-14980" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-14985" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-14986" href="../Lists/#plfa_plfa-part1-Lists-14986" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-14988" href="../Lists/#plfa_plfa-part1-Lists-14988" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-14990" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14992" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-14995" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-14997" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-14999" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-15003" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Tree.leaf"></a><a id="plfa_plfa-part1-Lists-15011" href="../Lists/#plfa_plfa-part1-Lists-15011" class="InductiveConstructor">leaf</a> <a id="plfa_plfa-part1-Lists-15016" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15018" href="../Lists/#plfa_plfa-part1-Lists-14986" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15020" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15022" href="../Lists/#plfa_plfa-part1-Lists-14980" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15027" href="../Lists/#plfa_plfa-part1-Lists-14986" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15029" href="../Lists/#plfa_plfa-part1-Lists-14988" class="Bound">B</a>
  <a id="plfa_plfa-part1-Lists-Tree.node"></a><a id="plfa_plfa-part1-Lists-15033" href="../Lists/#plfa_plfa-part1-Lists-15033" class="InductiveConstructor">node</a> <a id="plfa_plfa-part1-Lists-15038" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15040" href="../Lists/#plfa_plfa-part1-Lists-14980" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15045" href="../Lists/#plfa_plfa-part1-Lists-14986" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15047" href="../Lists/#plfa_plfa-part1-Lists-14988" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15049" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15051" href="../Lists/#plfa_plfa-part1-Lists-14988" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15053" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15055" href="../Lists/#plfa_plfa-part1-Lists-14980" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15060" href="../Lists/#plfa_plfa-part1-Lists-14986" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15062" href="../Lists/#plfa_plfa-part1-Lists-14988" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15064" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15066" href="../Lists/#plfa_plfa-part1-Lists-14980" class="Datatype">Tree</a> <a id="plfa_plfa-part1-Lists-15071" href="../Lists/#plfa_plfa-part1-Lists-14986" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15073" href="../Lists/#plfa_plfa-part1-Lists-14988" class="Bound">B</a>
</pre><p>Define a suitable map operator over trees:</p><pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-15207" class="Comment">-- Your code goes here</a>
</pre><h2 id="Fold">Fold</h2>Fold takes an operator and a value, and uses the operator to combine each of the elements of the list, taking the given value as the result for the empty list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr"></a><a id="plfa_plfa-part1-Lists-15420" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15426" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15428" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-15430" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-15431" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15433" href="../Lists/#plfa_plfa-part1-Lists-15433" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15435" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15437" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-15440" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-15442" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15444" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15445" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15447" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15449" href="../Lists/#plfa_plfa-part1-Lists-15433" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15451" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15453" href="../Lists/#plfa_plfa-part1-Lists-15433" class="Bound">B</a><a id="plfa_plfa-part1-Lists-15454" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-15456" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15458" href="../Lists/#plfa_plfa-part1-Lists-15433" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-15460" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15462" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-15467" href="../Lists/#plfa_plfa-part1-Lists-15431" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-15469" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-15471" href="../Lists/#plfa_plfa-part1-Lists-15433" class="Bound">B</a>
<a id="plfa_plfa-part1-Lists-15473" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15479" href="../Lists/#plfa_plfa-part1-Lists-15479" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15483" href="../Lists/#plfa_plfa-part1-Lists-15483" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15485" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>        <a id="plfa_plfa-part1-Lists-15495" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-15498" href="../Lists/#plfa_plfa-part1-Lists-15483" class="Bound">e</a>
<a id="plfa_plfa-part1-Lists-15500" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15506" href="../Lists/#plfa_plfa-part1-Lists-15506" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15510" href="../Lists/#plfa_plfa-part1-Lists-15510" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15512" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15513" href="../Lists/#plfa_plfa-part1-Lists-15513" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-15515" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15517" href="../Lists/#plfa_plfa-part1-Lists-15517" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-15519" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-15522" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-15525" href="../Lists/#plfa_plfa-part1-Lists-15513" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-15527" href="../Lists/#plfa_plfa-part1-Lists-15506" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-15529" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15535" href="../Lists/#plfa_plfa-part1-Lists-15506" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-15539" href="../Lists/#plfa_plfa-part1-Lists-15510" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-15541" href="../Lists/#plfa_plfa-part1-Lists-15517" class="Bound">xs</a>
</pre><p>Fold of the empty list is the given value. Fold of a non-empty list uses the operator to combine the head of the list and the fold of the tail of the list.</p>Here is an example showing how to use fold to find the sum of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-15783" href="../Lists/#plfa_plfa-part1-Lists-15783" class="Function">_</a> <a id="plfa_plfa-part1-Lists-15785" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-15787" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15793" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15797" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15799" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-15801" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15803" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15805" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15807" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15809" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15811" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-15813" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15815" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-15817" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-15819" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-15822" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-15824" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-15828" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-15838" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15844" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15848" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15850" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15851" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15853" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15855" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15857" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15859" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15861" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15863" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15865" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15867" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15869" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15873" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15881" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15883" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15885" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15891" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15895" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15897" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15898" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15900" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15902" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15904" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15906" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15908" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15910" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15912" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-15916" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15924" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15926" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15928" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15929" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15931" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15933" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15939" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15943" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15945" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15946" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15948" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15950" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15952" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-15954" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-15956" class="Symbol">))</a>
  <a id="plfa_plfa-part1-Lists-15961" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-15969" class="Number">1</a> <a id="plfa_plfa-part1-Lists-15971" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15973" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15974" class="Number">2</a> <a id="plfa_plfa-part1-Lists-15976" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15978" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15979" class="Number">3</a> <a id="plfa_plfa-part1-Lists-15981" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-15983" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-15989" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-15993" class="Number">0</a> <a id="plfa_plfa-part1-Lists-15995" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-15996" class="Number">4</a> <a id="plfa_plfa-part1-Lists-15998" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-16000" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16002" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16008" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16016" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16018" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16020" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16021" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16023" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16025" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16026" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16028" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16030" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16031" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16033" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16035" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16041" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16045" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16047" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-16049" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16055" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16063" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16065" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16067" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16068" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16070" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16072" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16073" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16075" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16077" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-16078" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16080" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="plfa_plfa-part1-Lists-16082" class="Number">0</a><a id="plfa_plfa-part1-Lists-16083" class="Symbol">)))</a>
  <a id="plfa_plfa-part1-Lists-16089" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>Here we have an instance of <code>foldr</code> where <code>A</code> and <code>B</code> are both <code>ℕ</code>. Fold requires time linear in the length of the list.</p>It is often convenient to exploit currying by applying fold to an operator and a value to yield a new function, and at a later point applying the resulting function:<pre class="Agda"><a id="plfa_plfa-part1-Lists-sum"></a><a id="plfa_plfa-part1-Lists-16391" href="../Lists/#plfa_plfa-part1-Lists-16391" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16395" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16397" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-16402" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-16404" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-16406" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-16408" href="../Lists/#plfa_plfa-part1-Lists-16391" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16412" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-16414" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16420" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16424" class="Number">0</a>

<a id="plfa_plfa-part1-Lists-16427" href="../Lists/#plfa_plfa-part1-Lists-16427" class="Function">_</a> <a id="plfa_plfa-part1-Lists-16429" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-16431" href="../Lists/#plfa_plfa-part1-Lists-16391" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16435" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16437" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16439" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16441" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16443" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16445" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16447" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16449" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16451" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-16453" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-16455" class="Number">10</a>
<a id="plfa_plfa-part1-Lists-16458" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-16460" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-16464" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-16474" href="../Lists/#plfa_plfa-part1-Lists-16391" class="Function">sum</a> <a id="plfa_plfa-part1-Lists-16478" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16480" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16482" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16484" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16486" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16488" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16490" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16492" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16494" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-16498" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16506" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-16512" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-16516" class="Number">0</a> <a id="plfa_plfa-part1-Lists-16518" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-16520" class="Number">1</a> <a id="plfa_plfa-part1-Lists-16522" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16524" class="Number">2</a> <a id="plfa_plfa-part1-Lists-16526" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16528" class="Number">3</a> <a id="plfa_plfa-part1-Lists-16530" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-16532" class="Number">4</a> <a id="plfa_plfa-part1-Lists-16534" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">]</a>
  <a id="plfa_plfa-part1-Lists-16538" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-16546" class="Number">10</a>
  <a id="plfa_plfa-part1-Lists-16551" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>Just as the list type has two constructors, <code>[]</code> and <code>_∷_</code>, so the fold function takes two arguments, <code>e</code> and <code>_⊗_</code> (in addition to the list argument). In general, a data type with <em>n</em> constructors will have a corresponding fold function that takes <em>n</em> arguments.</p><p>As another example, observe that</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Here, if <code>xs</code> is of type <code>List A</code>, then we see we have an instance of <code>foldr</code> where <code>A</code> is <code>A</code> and <code>B</code> is <code>List A</code>. It follows that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><p>Demonstrating both these equations is left as an exercise.</p><h4 id="exercise-product-recommended">Exercise <code>product</code> (recommended)</h4><p>Use fold to define a function to find the product of a list of numbers. For example:</p><pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17279" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr--recommended">Exercise <code>foldr-++</code> (recommended)</h4>Show that fold and append are related as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-17405" class="Keyword">postulate</a>
  <a id="plfa_plfa-part1-Lists-foldr-++"></a><a id="plfa_plfa-part1-Lists-17417" href="../Lists/#plfa_plfa-part1-Lists-17417" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-17426" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17428" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-17430" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-17431" href="../Lists/#plfa_plfa-part1-Lists-17431" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-17433" href="../Lists/#plfa_plfa-part1-Lists-17433" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-17435" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17437" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-17440" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-17442" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17443" href="../Lists/#plfa_plfa-part1-Lists-17443" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17447" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17449" href="../Lists/#plfa_plfa-part1-Lists-17431" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-17451" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17453" href="../Lists/#plfa_plfa-part1-Lists-17433" class="Bound">B</a> <a id="plfa_plfa-part1-Lists-17455" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-17457" href="../Lists/#plfa_plfa-part1-Lists-17433" class="Bound">B</a><a id="plfa_plfa-part1-Lists-17458" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17460" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17461" href="../Lists/#plfa_plfa-part1-Lists-17461" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17463" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17465" href="../Lists/#plfa_plfa-part1-Lists-17433" class="Bound">B</a><a id="plfa_plfa-part1-Lists-17466" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17468" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17469" href="../Lists/#plfa_plfa-part1-Lists-17469" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-17472" href="../Lists/#plfa_plfa-part1-Lists-17472" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-17475" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-17477" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-17482" href="../Lists/#plfa_plfa-part1-Lists-17431" class="Bound">A</a><a id="plfa_plfa-part1-Lists-17483" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17485" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-17491" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17497" href="../Lists/#plfa_plfa-part1-Lists-17443" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17501" href="../Lists/#plfa_plfa-part1-Lists-17461" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17503" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17504" href="../Lists/#plfa_plfa-part1-Lists-17469" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-17507" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-17510" href="../Lists/#plfa_plfa-part1-Lists-17472" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-17512" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17514" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-17516" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17522" href="../Lists/#plfa_plfa-part1-Lists-17443" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17526" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-17527" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-17533" href="../Lists/#plfa_plfa-part1-Lists-17443" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-17537" href="../Lists/#plfa_plfa-part1-Lists-17461" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-17539" href="../Lists/#plfa_plfa-part1-Lists-17472" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-17541" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-17543" href="../Lists/#plfa_plfa-part1-Lists-17469" class="Bound">xs</a>
</pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17559" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4><p>Show</p><pre><code>foldr _∷_ [] xs ≡ xs</code></pre><p>Show as a consequence of <code>foldr-++</code> above that</p><pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-17744" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-is-foldr-practice">Exercise <code>map-is-foldr</code> (practice)</h4><p>Show that map can be defined using fold:</p><pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre><p>The proof requires extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-17941" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-fold-tree-practice">Exercise <code>fold-Tree</code> (practice)</h4><p>Define a suitable fold function for the type of trees given earlier:</p><pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18162" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-map-is-fold-tree-practice">Exercise <code>map-is-fold-Tree</code> (practice)</h4><p>Demonstrate an analogue of <code>map-is-foldr</code> for the type of trees.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-18309" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-sum-downfrom-stretch">Exercise <code>sum-downFrom</code> (stretch)</h4>Define a function that counts down as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-downFrom"></a><a id="plfa_plfa-part1-Lists-18432" href="../Lists/#plfa_plfa-part1-Lists-18432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18441" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18443" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="plfa_plfa-part1-Lists-18445" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-18447" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-18452" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="plfa_plfa-part1-Lists-18454" href="../Lists/#plfa_plfa-part1-Lists-18432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18463" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="plfa_plfa-part1-Lists-18472" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-18475" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-18478" href="../Lists/#plfa_plfa-part1-Lists-18432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18487" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-18488" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="plfa_plfa-part1-Lists-18492" href="../Lists/#plfa_plfa-part1-Lists-18492" class="Bound">n</a><a id="plfa_plfa-part1-Lists-18493" class="Symbol">)</a>  <a id="plfa_plfa-part1-Lists-18496" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-18499" href="../Lists/#plfa_plfa-part1-Lists-18492" class="Bound">n</a> <a id="plfa_plfa-part1-Lists-18501" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-18503" href="../Lists/#plfa_plfa-part1-Lists-18432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18512" href="../Lists/#plfa_plfa-part1-Lists-18492" class="Bound">n</a>
</pre>For example:<pre class="Agda"><a id="plfa_plfa-part1-Lists-18539" href="../Lists/#plfa_plfa-part1-Lists-18539" class="Function">_</a> <a id="plfa_plfa-part1-Lists-18541" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-18543" href="../Lists/#plfa_plfa-part1-Lists-18432" class="Function">downFrom</a> <a id="plfa_plfa-part1-Lists-18552" class="Number">3</a> <a id="plfa_plfa-part1-Lists-18554" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-18556" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-18558" class="Number">2</a> <a id="plfa_plfa-part1-Lists-18560" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-18562" class="Number">1</a> <a id="plfa_plfa-part1-Lists-18564" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-18566" class="Number">0</a> <a id="plfa_plfa-part1-Lists-18568" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-18570" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-18572" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-18574" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre><p>Prove that the sum of the numbers <code>(n - 1) + ⋯ + 0</code> is equal to <code>n * (n ∸ 1) / 2</code>:</p><pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-18715" class="Comment">-- Your code goes here</a>
</pre><h2 id="monoids">Monoids</h2><p>Typically when we use a fold the operator is associative and the value is a left and right identity for the operator, meaning that the operator and the value form a <em>monoid</em>.</p>We can define a monoid as a suitable record type:<pre class="Agda"><a id="plfa_plfa-part1-Lists-18989" class="Keyword">record</a> <a id="plfa_plfa-part1-Lists-IsMonoid"></a><a id="plfa_plfa-part1-Lists-18996" href="../Lists/#plfa_plfa-part1-Lists-18996" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19005" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19006" href="../Lists/#plfa_plfa-part1-Lists-19006" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19008" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19010" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19013" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19015" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19016" href="../Lists/#plfa_plfa-part1-Lists-19016" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19020" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19022" href="../Lists/#plfa_plfa-part1-Lists-19006" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19024" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19026" href="../Lists/#plfa_plfa-part1-Lists-19006" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19028" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19030" href="../Lists/#plfa_plfa-part1-Lists-19006" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19031" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19033" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19034" href="../Lists/#plfa_plfa-part1-Lists-19034" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19036" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19038" href="../Lists/#plfa_plfa-part1-Lists-19006" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19039" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19041" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19043" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-19047" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-19055" class="Keyword">field</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.assoc"></a><a id="plfa_plfa-part1-Lists-19065" href="../Lists/#plfa_plfa-part1-Lists-19065" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19071" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19073" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19075" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19076" href="../Lists/#plfa_plfa-part1-Lists-19076" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19078" href="../Lists/#plfa_plfa-part1-Lists-19078" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19080" href="../Lists/#plfa_plfa-part1-Lists-19080" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-19082" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19084" href="../Lists/#plfa_plfa-part1-Lists-19006" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19085" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19087" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19089" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19090" href="../Lists/#plfa_plfa-part1-Lists-19076" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19092" href="../Lists/#plfa_plfa-part1-Lists-19016" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19094" href="../Lists/#plfa_plfa-part1-Lists-19078" class="Bound">y</a><a id="plfa_plfa-part1-Lists-19095" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19097" href="../Lists/#plfa_plfa-part1-Lists-19016" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19099" href="../Lists/#plfa_plfa-part1-Lists-19080" class="Bound">z</a> <a id="plfa_plfa-part1-Lists-19101" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19103" href="../Lists/#plfa_plfa-part1-Lists-19076" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19105" href="../Lists/#plfa_plfa-part1-Lists-19016" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19107" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19108" href="../Lists/#plfa_plfa-part1-Lists-19078" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19110" href="../Lists/#plfa_plfa-part1-Lists-19016" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19112" href="../Lists/#plfa_plfa-part1-Lists-19080" class="Bound">z</a><a id="plfa_plfa-part1-Lists-19113" class="Symbol">)</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityˡ"></a><a id="plfa_plfa-part1-Lists-19119" href="../Lists/#plfa_plfa-part1-Lists-19119" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19129" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19131" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19133" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19134" href="../Lists/#plfa_plfa-part1-Lists-19134" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19136" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19138" href="../Lists/#plfa_plfa-part1-Lists-19006" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19139" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19141" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19143" href="../Lists/#plfa_plfa-part1-Lists-19034" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19145" href="../Lists/#plfa_plfa-part1-Lists-19016" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19147" href="../Lists/#plfa_plfa-part1-Lists-19134" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19149" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19151" href="../Lists/#plfa_plfa-part1-Lists-19134" class="Bound">x</a>
    <a id="plfa_plfa-part1-Lists-IsMonoid.identityʳ"></a><a id="plfa_plfa-part1-Lists-19157" href="../Lists/#plfa_plfa-part1-Lists-19157" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19167" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19169" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19171" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19172" href="../Lists/#plfa_plfa-part1-Lists-19172" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19174" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19176" href="../Lists/#plfa_plfa-part1-Lists-19006" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19177" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19179" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19181" href="../Lists/#plfa_plfa-part1-Lists-19172" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-19183" href="../Lists/#plfa_plfa-part1-Lists-19016" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-19185" href="../Lists/#plfa_plfa-part1-Lists-19034" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19187" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19189" href="../Lists/#plfa_plfa-part1-Lists-19172" class="Bound">x</a>

<a id="plfa_plfa-part1-Lists-19192" class="Keyword">open</a> <a id="plfa_plfa-part1-Lists-19197" href="../Lists/#plfa_plfa-part1-Lists-18996" class="Module">IsMonoid</a>
</pre>As examples, sum and zero, multiplication and one, and append and the empty list, are all examples of monoids:<pre class="Agda"><a id="plfa_plfa-part1-Lists-+-monoid"></a><a id="plfa_plfa-part1-Lists-19330" href="../Lists/#plfa_plfa-part1-Lists-19330" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-19339" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19341" href="../Lists/#plfa_plfa-part1-Lists-18996" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19350" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="plfa_plfa-part1-Lists-19354" class="Number">0</a>
<a id="plfa_plfa-part1-Lists-19356" href="../Lists/#plfa_plfa-part1-Lists-19330" class="Function">+-monoid</a> <a id="plfa_plfa-part1-Lists-19365" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19369" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19380" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19382" href="../Lists/#plfa_plfa-part1-Lists-19065" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19388" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19390" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#13071" class="Function">+-assoc</a>
    <a id="plfa_plfa-part1-Lists-19402" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19404" href="../Lists/#plfa_plfa-part1-Lists-19119" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19414" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19416" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#13172" class="Function">+-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19432" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19434" href="../Lists/#plfa_plfa-part1-Lists-19157" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19444" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19446" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#13227" class="Function">+-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19462" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-*-monoid"></a><a id="plfa_plfa-part1-Lists-19465" href="../Lists/#plfa_plfa-part1-Lists-19465" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-19474" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19476" href="../Lists/#plfa_plfa-part1-Lists-18996" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19485" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Nat.html#522" class="Primitive Operator">_*_</a> <a id="plfa_plfa-part1-Lists-19489" class="Number">1</a>
<a id="plfa_plfa-part1-Lists-19491" href="../Lists/#plfa_plfa-part1-Lists-19465" class="Function">*-monoid</a> <a id="plfa_plfa-part1-Lists-19500" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19504" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19515" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19517" href="../Lists/#plfa_plfa-part1-Lists-19065" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19523" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19525" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#21055" class="Function">*-assoc</a>
    <a id="plfa_plfa-part1-Lists-19537" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19539" href="../Lists/#plfa_plfa-part1-Lists-19119" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19549" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19551" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#19955" class="Function">*-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19567" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19569" href="../Lists/#plfa_plfa-part1-Lists-19157" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19579" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19581" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Properties.html#20019" class="Function">*-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19597" class="Symbol">}</a>

<a id="plfa_plfa-part1-Lists-++-monoid"></a><a id="plfa_plfa-part1-Lists-19600" href="../Lists/#plfa_plfa-part1-Lists-19600" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-19610" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19612" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19614" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19615" href="../Lists/#plfa_plfa-part1-Lists-19615" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19617" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19619" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19622" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19624" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19626" href="../Lists/#plfa_plfa-part1-Lists-18996" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19635" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19636" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19641" href="../Lists/#plfa_plfa-part1-Lists-19615" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19642" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19644" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">_++_</a> <a id="plfa_plfa-part1-Lists-19649" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-19652" href="../Lists/#plfa_plfa-part1-Lists-19600" class="Function">++-monoid</a> <a id="plfa_plfa-part1-Lists-19662" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-19666" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-19677" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-19679" href="../Lists/#plfa_plfa-part1-Lists-19065" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-19685" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19687" href="../Lists/#plfa_plfa-part1-Lists-4520" class="Function">++-assoc</a>
    <a id="plfa_plfa-part1-Lists-19700" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19702" href="../Lists/#plfa_plfa-part1-Lists-19119" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-19712" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19714" href="../Lists/#plfa_plfa-part1-Lists-5717" class="Function">++-identityˡ</a>
    <a id="plfa_plfa-part1-Lists-19731" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-19733" href="../Lists/#plfa_plfa-part1-Lists-19157" class="Field">identityʳ</a> <a id="plfa_plfa-part1-Lists-19743" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-19745" href="../Lists/#plfa_plfa-part1-Lists-5899" class="Function">++-identityʳ</a>
    <a id="plfa_plfa-part1-Lists-19762" class="Symbol">}</a>
</pre>If <code>_⊗_</code> and <code>e</code> form a monoid, then we can re-express fold on the same operator and an arbitrary value:<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid"></a><a id="plfa_plfa-part1-Lists-19882" href="../Lists/#plfa_plfa-part1-Lists-19882" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-19895" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19897" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19899" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-19900" href="../Lists/#plfa_plfa-part1-Lists-19900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19902" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19904" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-19907" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-19909" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19910" href="../Lists/#plfa_plfa-part1-Lists-19910" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19914" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19916" href="../Lists/#plfa_plfa-part1-Lists-19900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19918" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19920" href="../Lists/#plfa_plfa-part1-Lists-19900" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-19922" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19924" href="../Lists/#plfa_plfa-part1-Lists-19900" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19925" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19927" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19928" href="../Lists/#plfa_plfa-part1-Lists-19928" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19930" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19932" href="../Lists/#plfa_plfa-part1-Lists-19900" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19933" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19935" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19937" href="../Lists/#plfa_plfa-part1-Lists-18996" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-19946" href="../Lists/#plfa_plfa-part1-Lists-19910" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19950" href="../Lists/#plfa_plfa-part1-Lists-19928" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-19952" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-19956" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-19958" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19959" href="../Lists/#plfa_plfa-part1-Lists-19959" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-19962" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19964" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-19969" href="../Lists/#plfa_plfa-part1-Lists-19900" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19970" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19972" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-19973" href="../Lists/#plfa_plfa-part1-Lists-19973" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19975" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-19977" href="../Lists/#plfa_plfa-part1-Lists-19900" class="Bound">A</a><a id="plfa_plfa-part1-Lists-19978" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-19980" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-19982" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-19988" href="../Lists/#plfa_plfa-part1-Lists-19910" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-19992" href="../Lists/#plfa_plfa-part1-Lists-19973" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-19994" href="../Lists/#plfa_plfa-part1-Lists-19959" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-19997" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-19999" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20005" href="../Lists/#plfa_plfa-part1-Lists-19910" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20009" href="../Lists/#plfa_plfa-part1-Lists-19928" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20011" href="../Lists/#plfa_plfa-part1-Lists-19959" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20014" href="../Lists/#plfa_plfa-part1-Lists-19910" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20016" href="../Lists/#plfa_plfa-part1-Lists-19973" class="Bound">y</a>
<a id="plfa_plfa-part1-Lists-20018" href="../Lists/#plfa_plfa-part1-Lists-19882" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20031" href="../Lists/#plfa_plfa-part1-Lists-20031" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20035" href="../Lists/#plfa_plfa-part1-Lists-20035" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20037" href="../Lists/#plfa_plfa-part1-Lists-20037" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20046" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-20049" href="../Lists/#plfa_plfa-part1-Lists-20049" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20051" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20055" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20065" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20071" href="../Lists/#plfa_plfa-part1-Lists-20031" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20075" href="../Lists/#plfa_plfa-part1-Lists-20049" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20077" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-20082" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20090" href="../Lists/#plfa_plfa-part1-Lists-20049" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20094" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20097" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-20101" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20102" href="../Lists/#plfa_plfa-part1-Lists-19119" class="Field">identityˡ</a> <a id="plfa_plfa-part1-Lists-20112" href="../Lists/#plfa_plfa-part1-Lists-20037" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20121" href="../Lists/#plfa_plfa-part1-Lists-20049" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20122" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20124" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20130" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20131" href="../Lists/#plfa_plfa-part1-Lists-20035" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20133" href="../Lists/#plfa_plfa-part1-Lists-20031" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20135" href="../Lists/#plfa_plfa-part1-Lists-20049" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20136" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20140" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20148" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20154" href="../Lists/#plfa_plfa-part1-Lists-20031" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20158" href="../Lists/#plfa_plfa-part1-Lists-20035" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20160" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-20163" href="../Lists/#plfa_plfa-part1-Lists-20031" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20165" href="../Lists/#plfa_plfa-part1-Lists-20049" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20169" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
<a id="plfa_plfa-part1-Lists-20171" href="../Lists/#plfa_plfa-part1-Lists-19882" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20184" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20188" href="../Lists/#plfa_plfa-part1-Lists-20188" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20190" href="../Lists/#plfa_plfa-part1-Lists-20190" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20199" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20200" href="../Lists/#plfa_plfa-part1-Lists-20200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20202" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20204" href="../Lists/#plfa_plfa-part1-Lists-20204" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20206" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20208" href="../Lists/#plfa_plfa-part1-Lists-20208" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20210" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20214" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20224" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20230" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20234" href="../Lists/#plfa_plfa-part1-Lists-20208" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20236" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20237" href="../Lists/#plfa_plfa-part1-Lists-20200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20239" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20241" href="../Lists/#plfa_plfa-part1-Lists-20204" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20243" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20247" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20255" href="../Lists/#plfa_plfa-part1-Lists-20200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20257" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20259" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20260" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20266" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20270" href="../Lists/#plfa_plfa-part1-Lists-20208" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-20272" href="../Lists/#plfa_plfa-part1-Lists-20204" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20274" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20278" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20281" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1139" class="Function">cong</a> <a id="plfa_plfa-part1-Lists-20286" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20287" href="../Lists/#plfa_plfa-part1-Lists-20200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20289" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">⊗_</a><a id="plfa_plfa-part1-Lists-20291" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20293" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20294" href="../Lists/#plfa_plfa-part1-Lists-19882" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-20307" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20311" href="../Lists/#plfa_plfa-part1-Lists-20188" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20313" href="../Lists/#plfa_plfa-part1-Lists-20190" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20322" href="../Lists/#plfa_plfa-part1-Lists-20204" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20325" href="../Lists/#plfa_plfa-part1-Lists-20208" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20326" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20328" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20334" href="../Lists/#plfa_plfa-part1-Lists-20200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20336" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20338" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20339" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20345" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20349" href="../Lists/#plfa_plfa-part1-Lists-20188" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20351" href="../Lists/#plfa_plfa-part1-Lists-20204" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20354" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20356" href="../Lists/#plfa_plfa-part1-Lists-20208" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20357" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20361" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20364" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="plfa_plfa-part1-Lists-20368" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20369" href="../Lists/#plfa_plfa-part1-Lists-19065" class="Field">assoc</a> <a id="plfa_plfa-part1-Lists-20375" href="../Lists/#plfa_plfa-part1-Lists-20190" class="Bound">⊗-monoid</a> <a id="plfa_plfa-part1-Lists-20384" href="../Lists/#plfa_plfa-part1-Lists-20200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20386" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20387" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20393" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20397" href="../Lists/#plfa_plfa-part1-Lists-20188" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20399" href="../Lists/#plfa_plfa-part1-Lists-20204" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20401" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20403" href="../Lists/#plfa_plfa-part1-Lists-20208" class="Bound">y</a><a id="plfa_plfa-part1-Lists-20404" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20406" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20412" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20413" href="../Lists/#plfa_plfa-part1-Lists-20200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20415" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20417" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20423" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20427" href="../Lists/#plfa_plfa-part1-Lists-20188" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20429" href="../Lists/#plfa_plfa-part1-Lists-20204" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20431" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20433" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20435" href="../Lists/#plfa_plfa-part1-Lists-20208" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20439" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2873" class="Function Operator">≡⟨⟩</a>
    <a id="plfa_plfa-part1-Lists-20447" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20453" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20457" href="../Lists/#plfa_plfa-part1-Lists-20188" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20459" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20460" href="../Lists/#plfa_plfa-part1-Lists-20200" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-20462" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-20464" href="../Lists/#plfa_plfa-part1-Lists-20204" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-20466" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20468" href="../Lists/#plfa_plfa-part1-Lists-20184" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20470" href="../Lists/#plfa_plfa-part1-Lists-20208" class="Bound">y</a>
  <a id="plfa_plfa-part1-Lists-20474" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><p>In exercise <code>foldr-++</code> above we showed the following:</p><pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre>As a consequence we can decompose fold over append in a monoid into two folds as follows.<pre class="Agda"><a id="plfa_plfa-part1-Lists-foldr-monoid-++"></a><a id="plfa_plfa-part1-Lists-20694" href="../Lists/#plfa_plfa-part1-Lists-20694" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-20710" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20712" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20714" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-20715" href="../Lists/#plfa_plfa-part1-Lists-20715" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20717" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20719" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-20722" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-20724" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20725" href="../Lists/#plfa_plfa-part1-Lists-20725" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20729" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20731" href="../Lists/#plfa_plfa-part1-Lists-20715" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20733" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20735" href="../Lists/#plfa_plfa-part1-Lists-20715" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-20737" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20739" href="../Lists/#plfa_plfa-part1-Lists-20715" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20740" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20742" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20743" href="../Lists/#plfa_plfa-part1-Lists-20743" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20745" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20747" href="../Lists/#plfa_plfa-part1-Lists-20715" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20748" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20750" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20752" href="../Lists/#plfa_plfa-part1-Lists-18996" class="Record">IsMonoid</a> <a id="plfa_plfa-part1-Lists-20761" href="../Lists/#plfa_plfa-part1-Lists-20725" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20765" href="../Lists/#plfa_plfa-part1-Lists-20743" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20767" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-20771" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-20773" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20774" href="../Lists/#plfa_plfa-part1-Lists-20774" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20777" href="../Lists/#plfa_plfa-part1-Lists-20777" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20780" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-20782" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-20787" href="../Lists/#plfa_plfa-part1-Lists-20715" class="Bound">A</a><a id="plfa_plfa-part1-Lists-20788" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20790" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-20792" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20798" href="../Lists/#plfa_plfa-part1-Lists-20725" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20802" href="../Lists/#plfa_plfa-part1-Lists-20743" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20804" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20805" href="../Lists/#plfa_plfa-part1-Lists-20774" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20808" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-20811" href="../Lists/#plfa_plfa-part1-Lists-20777" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20813" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20815" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="plfa_plfa-part1-Lists-20817" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20823" href="../Lists/#plfa_plfa-part1-Lists-20725" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20827" href="../Lists/#plfa_plfa-part1-Lists-20743" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20829" href="../Lists/#plfa_plfa-part1-Lists-20774" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20832" href="../Lists/#plfa_plfa-part1-Lists-20725" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-20834" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20840" href="../Lists/#plfa_plfa-part1-Lists-20725" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20844" href="../Lists/#plfa_plfa-part1-Lists-20743" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20846" href="../Lists/#plfa_plfa-part1-Lists-20777" class="Bound">ys</a>
<a id="plfa_plfa-part1-Lists-20849" href="../Lists/#plfa_plfa-part1-Lists-20694" class="Function">foldr-monoid-++</a> <a id="plfa_plfa-part1-Lists-20865" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20869" href="../Lists/#plfa_plfa-part1-Lists-20869" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20871" href="../Lists/#plfa_plfa-part1-Lists-20871" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-20880" href="../Lists/#plfa_plfa-part1-Lists-20880" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20883" href="../Lists/#plfa_plfa-part1-Lists-20883" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20886" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-20890" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="plfa_plfa-part1-Lists-20900" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20906" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20910" href="../Lists/#plfa_plfa-part1-Lists-20869" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20912" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20913" href="../Lists/#plfa_plfa-part1-Lists-20880" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20916" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-20919" href="../Lists/#plfa_plfa-part1-Lists-20883" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20921" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-20925" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20928" href="../Lists/#plfa_plfa-part1-Lists-17417" class="Postulate">foldr-++</a> <a id="plfa_plfa-part1-Lists-20937" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20941" href="../Lists/#plfa_plfa-part1-Lists-20869" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20943" href="../Lists/#plfa_plfa-part1-Lists-20880" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-20946" href="../Lists/#plfa_plfa-part1-Lists-20883" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-20949" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-20955" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20961" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20965" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-20966" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-20972" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-20976" href="../Lists/#plfa_plfa-part1-Lists-20869" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-20978" href="../Lists/#plfa_plfa-part1-Lists-20883" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-20980" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-20982" href="../Lists/#plfa_plfa-part1-Lists-20880" class="Bound">xs</a>
  <a id="plfa_plfa-part1-Lists-20987" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="plfa_plfa-part1-Lists-20990" href="../Lists/#plfa_plfa-part1-Lists-19882" class="Function">foldr-monoid</a> <a id="plfa_plfa-part1-Lists-21003" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21007" href="../Lists/#plfa_plfa-part1-Lists-20869" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21009" href="../Lists/#plfa_plfa-part1-Lists-20871" class="Bound">monoid-⊗</a> <a id="plfa_plfa-part1-Lists-21018" href="../Lists/#plfa_plfa-part1-Lists-20880" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21021" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21022" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21028" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21032" href="../Lists/#plfa_plfa-part1-Lists-20869" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21034" href="../Lists/#plfa_plfa-part1-Lists-20883" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-21036" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-21038" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="plfa_plfa-part1-Lists-21044" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21050" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21054" href="../Lists/#plfa_plfa-part1-Lists-20869" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21056" href="../Lists/#plfa_plfa-part1-Lists-20880" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21059" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">⊗</a> <a id="plfa_plfa-part1-Lists-21061" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-21067" href="../Lists/#plfa_plfa-part1-Lists-20865" class="Bound Operator">_⊗_</a> <a id="plfa_plfa-part1-Lists-21071" href="../Lists/#plfa_plfa-part1-Lists-20869" class="Bound">e</a> <a id="plfa_plfa-part1-Lists-21073" href="../Lists/#plfa_plfa-part1-Lists-20883" class="Bound">ys</a>
  <a id="plfa_plfa-part1-Lists-21078" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a>
</pre><h4 id="exercise-foldl-practice">Exercise <code>foldl</code> (practice)</h4><p>Define a function <code>foldl</code> which is analogous to <code>foldr</code>, but where operations associate to the left rather than the right. For example:</p><pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-21370" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-foldr-monoid-foldl-practice">Exercise <code>foldr-monoid-foldl</code> (practice)</h4><p>Show that if <code>_⊗_</code> and <code>e</code> form a monoid, then <code>foldr _⊗_ e</code> and <code>foldl _⊗_ e</code> always compute the same result.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-21566" class="Comment">-- Your code goes here</a>
</pre><h2 id="All">All</h2><p>We can also define predicates over lists. Two of the most important are <code>All</code> and <code>Any</code>.</p>Predicate <code>All P</code> holds if predicate <code>P</code> is satisfied by every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-21790" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-All"></a><a id="plfa_plfa-part1-Lists-21795" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21799" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-21800" href="../Lists/#plfa_plfa-part1-Lists-21800" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-21802" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21804" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-21807" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-21809" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21810" href="../Lists/#plfa_plfa-part1-Lists-21810" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21812" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21814" href="../Lists/#plfa_plfa-part1-Lists-21800" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-21816" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21818" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-21821" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-21823" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21825" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-21830" href="../Lists/#plfa_plfa-part1-Lists-21800" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-21832" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21834" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-21838" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-All.[]"></a><a id="plfa_plfa-part1-Lists-21846" href="../Lists/#plfa_plfa-part1-Lists-21846" class="InductiveConstructor">[]</a>  <a id="plfa_plfa-part1-Lists-21850" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21852" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21856" href="../Lists/#plfa_plfa-part1-Lists-21810" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21858" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>
  <a id="plfa_plfa-part1-Lists-All._∷_"></a><a id="plfa_plfa-part1-Lists-21863" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">_∷_</a> <a id="plfa_plfa-part1-Lists-21867" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21869" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-21871" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-21872" href="../Lists/#plfa_plfa-part1-Lists-21872" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-21874" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21876" href="../Lists/#plfa_plfa-part1-Lists-21800" class="Bound">A</a><a id="plfa_plfa-part1-Lists-21877" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-21879" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-21880" href="../Lists/#plfa_plfa-part1-Lists-21880" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21883" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-21885" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-21890" href="../Lists/#plfa_plfa-part1-Lists-21800" class="Bound">A</a><a id="plfa_plfa-part1-Lists-21891" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-21893" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21895" href="../Lists/#plfa_plfa-part1-Lists-21810" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21897" href="../Lists/#plfa_plfa-part1-Lists-21872" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-21899" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21901" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21905" href="../Lists/#plfa_plfa-part1-Lists-21810" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21907" href="../Lists/#plfa_plfa-part1-Lists-21880" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-21910" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-21912" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-21916" href="../Lists/#plfa_plfa-part1-Lists-21810" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-21918" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-21919" href="../Lists/#plfa_plfa-part1-Lists-21872" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-21921" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-21923" href="../Lists/#plfa_plfa-part1-Lists-21880" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-21925" class="Symbol">)</a>
</pre><p>The type has two constructors, reusing the names of the same constructors for lists. The first asserts that <code>P</code> holds for every element of the empty list. The second asserts that if <code>P</code> holds of the head of a list and for every element of the tail of a list, then <code>P</code> holds for every element of the list. Agda uses types to disambiguate whether the constructor is building a list or evidence that <code>All P</code> holds.</p>For example, <code>All (_≤ 2)</code> holds of a list where every element is less than or equal to two. Recall that <code>z≤n</code> proves <code>zero ≤ n</code> for any <code>n</code>, and that if <code>m≤n</code> proves <code>m ≤ n</code> then <code>s≤s m≤n</code> proves <code>suc m ≤ suc n</code>, for any <code>m</code> and <code>n</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-22587" href="../Lists/#plfa_plfa-part1-Lists-22587" class="Function">_</a> <a id="plfa_plfa-part1-Lists-22589" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-22591" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-22595" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22596" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1544" class="Datatype Operator">_≤</a> <a id="plfa_plfa-part1-Lists-22599" class="Number">2</a><a id="plfa_plfa-part1-Lists-22600" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22602" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-22604" class="Number">0</a> <a id="plfa_plfa-part1-Lists-22606" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-22608" class="Number">1</a> <a id="plfa_plfa-part1-Lists-22610" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-22612" class="Number">2</a> <a id="plfa_plfa-part1-Lists-22614" href="../Lists/#plfa_plfa-part1-Lists-2861" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-22616" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-22618" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-22620" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-22624" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22626" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1609" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22630" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a> <a id="plfa_plfa-part1-Lists-22634" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22636" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1609" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22640" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-22641" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1609" class="InductiveConstructor">s≤s</a> <a id="plfa_plfa-part1-Lists-22645" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a><a id="plfa_plfa-part1-Lists-22648" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-22650" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-22652" href="../Lists/#plfa_plfa-part1-Lists-21846" class="InductiveConstructor">[]</a>
</pre><p>Here <code>_∷_</code> and <code>[]</code> are the constructors of <code>All P</code> rather than of <code>List A</code>. The three items are proofs of <code>0 ≤ 2</code>, <code>1 ≤ 2</code>, and <code>2 ≤ 2</code>, respectively.</p><p>(One might wonder whether a pattern such as <code>[_,_,_]</code> can be used to construct values of type <code>All</code> as well as type <code>List</code>, since both use the same constructors. Indeed it can, so long as both types are in scope when the pattern is declared. That’s not the case here, since <code>List</code> is defined before <code>[_,_,_]</code>, but <code>All</code> is defined later.)</p><h2 id="any">Any</h2>Predicate <code>Any P</code> holds if predicate <code>P</code> is satisfied by some element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23251" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-Any"></a><a id="plfa_plfa-part1-Lists-23256" href="../Lists/#plfa_plfa-part1-Lists-23256" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23260" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23261" href="../Lists/#plfa_plfa-part1-Lists-23261" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23263" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23265" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23268" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23270" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23271" href="../Lists/#plfa_plfa-part1-Lists-23271" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23273" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23275" href="../Lists/#plfa_plfa-part1-Lists-23261" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23277" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23279" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23282" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23284" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23286" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23291" href="../Lists/#plfa_plfa-part1-Lists-23261" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23293" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23295" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-23299" class="Keyword">where</a>
  <a id="plfa_plfa-part1-Lists-Any.here"></a><a id="plfa_plfa-part1-Lists-23307" href="../Lists/#plfa_plfa-part1-Lists-23307" class="InductiveConstructor">here</a>  <a id="plfa_plfa-part1-Lists-23313" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23315" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23317" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23318" href="../Lists/#plfa_plfa-part1-Lists-23318" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23320" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23322" href="../Lists/#plfa_plfa-part1-Lists-23261" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23323" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23325" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23326" href="../Lists/#plfa_plfa-part1-Lists-23326" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23329" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23331" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23336" href="../Lists/#plfa_plfa-part1-Lists-23261" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23337" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23339" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23341" href="../Lists/#plfa_plfa-part1-Lists-23271" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23343" href="../Lists/#plfa_plfa-part1-Lists-23318" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23345" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23347" href="../Lists/#plfa_plfa-part1-Lists-23256" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23351" href="../Lists/#plfa_plfa-part1-Lists-23271" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23353" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23354" href="../Lists/#plfa_plfa-part1-Lists-23318" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23356" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23358" href="../Lists/#plfa_plfa-part1-Lists-23326" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23360" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-Any.there"></a><a id="plfa_plfa-part1-Lists-23364" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-23370" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23372" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23374" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23375" href="../Lists/#plfa_plfa-part1-Lists-23375" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23377" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23379" href="../Lists/#plfa_plfa-part1-Lists-23261" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23380" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23382" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23383" href="../Lists/#plfa_plfa-part1-Lists-23383" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23386" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23388" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23393" href="../Lists/#plfa_plfa-part1-Lists-23261" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23394" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23396" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23398" href="../Lists/#plfa_plfa-part1-Lists-23256" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23402" href="../Lists/#plfa_plfa-part1-Lists-23271" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23404" href="../Lists/#plfa_plfa-part1-Lists-23383" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23407" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23409" href="../Lists/#plfa_plfa-part1-Lists-23256" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23413" href="../Lists/#plfa_plfa-part1-Lists-23271" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-23415" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23416" href="../Lists/#plfa_plfa-part1-Lists-23375" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23418" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-23420" href="../Lists/#plfa_plfa-part1-Lists-23383" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23422" class="Symbol">)</a>
</pre>The first constructor provides evidence that the head of the list satisfies <code>P</code>, while the second provides evidence that some element of the tail of the list satisfies <code>P</code>. For example, we can define list membership as follows:<pre class="Agda"><a id="plfa_plfa-part1-Lists-23665" class="Keyword">infix</a> <a id="plfa_plfa-part1-Lists-23671" class="Number">4</a> <a id="plfa_plfa-part1-Lists-23673" href="../Lists/#plfa_plfa-part1-Lists-23682" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-23677" href="../Lists/#plfa_plfa-part1-Lists-23752" class="Function Operator">_∉_</a>

<a id="plfa_plfa-part1-Lists-_∈_"></a><a id="plfa_plfa-part1-Lists-23682" href="../Lists/#plfa_plfa-part1-Lists-23682" class="Function Operator">_∈_</a> <a id="plfa_plfa-part1-Lists-23686" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23688" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23690" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23691" href="../Lists/#plfa_plfa-part1-Lists-23691" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23693" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23695" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23698" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23700" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23701" href="../Lists/#plfa_plfa-part1-Lists-23701" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23703" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23705" href="../Lists/#plfa_plfa-part1-Lists-23691" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23706" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23708" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23709" href="../Lists/#plfa_plfa-part1-Lists-23709" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23712" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23714" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23719" href="../Lists/#plfa_plfa-part1-Lists-23691" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23720" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23722" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23724" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-23728" href="../Lists/#plfa_plfa-part1-Lists-23728" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23730" href="../Lists/#plfa_plfa-part1-Lists-23682" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23732" href="../Lists/#plfa_plfa-part1-Lists-23732" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23735" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23737" href="../Lists/#plfa_plfa-part1-Lists-23256" class="Datatype">Any</a> <a id="plfa_plfa-part1-Lists-23741" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23742" href="../Lists/#plfa_plfa-part1-Lists-23728" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23744" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#133" class="Datatype Operator">≡_</a><a id="plfa_plfa-part1-Lists-23746" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23748" href="../Lists/#plfa_plfa-part1-Lists-23732" class="Bound">xs</a>

<a id="plfa_plfa-part1-Lists-_∉_"></a><a id="plfa_plfa-part1-Lists-23752" href="../Lists/#plfa_plfa-part1-Lists-23752" class="Function Operator">_∉_</a> <a id="plfa_plfa-part1-Lists-23756" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23758" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-23760" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-23761" href="../Lists/#plfa_plfa-part1-Lists-23761" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-23763" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23765" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-23768" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-23770" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23771" href="../Lists/#plfa_plfa-part1-Lists-23771" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23773" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23775" href="../Lists/#plfa_plfa-part1-Lists-23761" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23776" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23778" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23779" href="../Lists/#plfa_plfa-part1-Lists-23779" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23782" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-23784" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-23789" href="../Lists/#plfa_plfa-part1-Lists-23761" class="Bound">A</a><a id="plfa_plfa-part1-Lists-23790" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-23792" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-23794" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-23798" href="../Lists/#plfa_plfa-part1-Lists-23798" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23800" href="../Lists/#plfa_plfa-part1-Lists-23752" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-23802" href="../Lists/#plfa_plfa-part1-Lists-23802" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-23805" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-23807" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="plfa_plfa-part1-Lists-23809" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-23810" href="../Lists/#plfa_plfa-part1-Lists-23798" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-23812" href="../Lists/#plfa_plfa-part1-Lists-23682" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-23814" href="../Lists/#plfa_plfa-part1-Lists-23802" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-23816" class="Symbol">)</a>
</pre>For example, zero is an element of the list <code>[ 0 , 1 , 0 , 2 ]</code>. Indeed, we can demonstrate this fact in two different ways, corresponding to the two different occurrences of zero in the list, as the first element and as the third element:<pre class="Agda"><a id="plfa_plfa-part1-Lists-24071" href="../Lists/#plfa_plfa-part1-Lists-24071" class="Function">_</a> <a id="plfa_plfa-part1-Lists-24073" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24075" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24077" href="../Lists/#plfa_plfa-part1-Lists-23682" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-24079" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24081" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24083" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24085" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24087" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24089" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24091" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24093" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24095" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24097" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-24099" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24101" href="../Lists/#plfa_plfa-part1-Lists-23307" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24106" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="plfa_plfa-part1-Lists-24112" href="../Lists/#plfa_plfa-part1-Lists-24112" class="Function">_</a> <a id="plfa_plfa-part1-Lists-24114" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24116" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24118" href="../Lists/#plfa_plfa-part1-Lists-23682" class="Function Operator">∈</a> <a id="plfa_plfa-part1-Lists-24120" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24122" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24124" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24126" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24128" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24130" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24132" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24134" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24136" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24138" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-24140" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-24142" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24148" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24149" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24155" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24156" href="../Lists/#plfa_plfa-part1-Lists-23307" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24161" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="plfa_plfa-part1-Lists-24165" class="Symbol">))</a>
</pre>Further, we can demonstrate that three is not in the list, because any possible proof that it is in the list leads to contradiction:<pre class="Agda"><a id="plfa_plfa-part1-Lists-not-in"></a><a id="plfa_plfa-part1-Lists-24313" href="../Lists/#plfa_plfa-part1-Lists-24313" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24320" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24322" class="Number">3</a> <a id="plfa_plfa-part1-Lists-24324" href="../Lists/#plfa_plfa-part1-Lists-23752" class="Function Operator">∉</a> <a id="plfa_plfa-part1-Lists-24326" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-24328" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24330" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24332" class="Number">1</a> <a id="plfa_plfa-part1-Lists-24334" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24336" class="Number">0</a> <a id="plfa_plfa-part1-Lists-24338" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-24340" class="Number">2</a> <a id="plfa_plfa-part1-Lists-24342" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-24344" href="../Lists/#plfa_plfa-part1-Lists-24313" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24351" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24352" href="../Lists/#plfa_plfa-part1-Lists-23307" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24357" class="Symbol">())</a>
<a id="plfa_plfa-part1-Lists-24361" href="../Lists/#plfa_plfa-part1-Lists-24313" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24368" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24369" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24375" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24376" href="../Lists/#plfa_plfa-part1-Lists-23307" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24381" class="Symbol">()))</a>
<a id="plfa_plfa-part1-Lists-24386" href="../Lists/#plfa_plfa-part1-Lists-24313" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24393" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24394" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24400" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24401" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24407" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24408" href="../Lists/#plfa_plfa-part1-Lists-23307" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24413" class="Symbol">())))</a>
<a id="plfa_plfa-part1-Lists-24419" href="../Lists/#plfa_plfa-part1-Lists-24313" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24426" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24427" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24433" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24434" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24440" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24441" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24447" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24448" href="../Lists/#plfa_plfa-part1-Lists-23307" class="InductiveConstructor">here</a> <a id="plfa_plfa-part1-Lists-24453" class="Symbol">()))))</a>
<a id="plfa_plfa-part1-Lists-24460" href="../Lists/#plfa_plfa-part1-Lists-24313" class="Function">not-in</a> <a id="plfa_plfa-part1-Lists-24467" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24468" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24474" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24475" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24481" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24482" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24488" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24489" href="../Lists/#plfa_plfa-part1-Lists-23364" class="InductiveConstructor">there</a> <a id="plfa_plfa-part1-Lists-24495" class="Symbol">()))))</a>
</pre><p>The five occurrences of <code>()</code> attest to the fact that there is no possible evidence for <code>3 ≡ 0</code>, <code>3 ≡ 1</code>, <code>3 ≡ 0</code>, <code>3 ≡ 2</code>, and <code>3 ∈ []</code>, respectively.</p><h2 id="all-and-append">All and append</h2>A predicate holds for every element of one list appended to another if and only if it holds for every element of both lists:<pre class="Agda"><a id="plfa_plfa-part1-Lists-All-++-⇔"></a><a id="plfa_plfa-part1-Lists-24810" href="../Lists/#plfa_plfa-part1-Lists-24810" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-24819" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24821" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-24823" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24824" href="../Lists/#plfa_plfa-part1-Lists-24824" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24826" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24828" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24831" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24833" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-24834" href="../Lists/#plfa_plfa-part1-Lists-24834" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24836" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24838" href="../Lists/#plfa_plfa-part1-Lists-24824" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-24840" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-24842" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-24845" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-24847" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24848" href="../Lists/#plfa_plfa-part1-Lists-24848" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24851" href="../Lists/#plfa_plfa-part1-Lists-24851" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-24854" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-24856" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-24861" href="../Lists/#plfa_plfa-part1-Lists-24824" class="Bound">A</a><a id="plfa_plfa-part1-Lists-24862" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24864" class="Symbol">→</a>
  <a id="plfa_plfa-part1-Lists-24868" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24872" href="../Lists/#plfa_plfa-part1-Lists-24834" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24874" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24875" href="../Lists/#plfa_plfa-part1-Lists-24848" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24878" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-24881" href="../Lists/#plfa_plfa-part1-Lists-24851" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-24883" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-24885" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12023" class="Record Operator">⇔</a> <a id="plfa_plfa-part1-Lists-24887" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-24888" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24892" href="../Lists/#plfa_plfa-part1-Lists-24834" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24894" href="../Lists/#plfa_plfa-part1-Lists-24848" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24897" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-24899" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-24903" href="../Lists/#plfa_plfa-part1-Lists-24834" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-24905" href="../Lists/#plfa_plfa-part1-Lists-24851" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-24907" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-24909" href="../Lists/#plfa_plfa-part1-Lists-24810" class="Function">All-++-⇔</a> <a id="plfa_plfa-part1-Lists-24918" href="../Lists/#plfa_plfa-part1-Lists-24918" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24921" href="../Lists/#plfa_plfa-part1-Lists-24921" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-24924" class="Symbol">=</a>
  <a id="plfa_plfa-part1-Lists-24928" class="Keyword">record</a>
    <a id="plfa_plfa-part1-Lists-24939" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-24941" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12063" class="Field">to</a>       <a id="plfa_plfa-part1-Lists-24950" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-24953" href="../Lists/#plfa_plfa-part1-Lists-25008" class="Function">to</a> <a id="plfa_plfa-part1-Lists-24956" href="../Lists/#plfa_plfa-part1-Lists-24918" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24959" href="../Lists/#plfa_plfa-part1-Lists-24921" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-24966" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-24968" href="../Isomorphism/#plfa_plfa-part1-Isomorphism-12080" class="Field">from</a>     <a id="plfa_plfa-part1-Lists-24977" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-24980" href="../Lists/#plfa_plfa-part1-Lists-25233" class="Function">from</a> <a id="plfa_plfa-part1-Lists-24985" href="../Lists/#plfa_plfa-part1-Lists-24918" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-24988" href="../Lists/#plfa_plfa-part1-Lists-24921" class="Bound">ys</a>
    <a id="plfa_plfa-part1-Lists-24995" class="Symbol">}</a>
  <a id="plfa_plfa-part1-Lists-24999" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-25008" href="../Lists/#plfa_plfa-part1-Lists-25008" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25011" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25013" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25015" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25016" href="../Lists/#plfa_plfa-part1-Lists-25016" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25018" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25020" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25023" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25025" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25026" href="../Lists/#plfa_plfa-part1-Lists-25026" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25028" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25030" href="../Lists/#plfa_plfa-part1-Lists-25016" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25032" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25034" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25037" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25039" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25040" href="../Lists/#plfa_plfa-part1-Lists-25040" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25043" href="../Lists/#plfa_plfa-part1-Lists-25043" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25046" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25048" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25053" href="../Lists/#plfa_plfa-part1-Lists-25016" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25054" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25056" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25062" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25066" href="../Lists/#plfa_plfa-part1-Lists-25026" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25068" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25069" href="../Lists/#plfa_plfa-part1-Lists-25040" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25072" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25075" href="../Lists/#plfa_plfa-part1-Lists-25043" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25077" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25079" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25081" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25082" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25086" href="../Lists/#plfa_plfa-part1-Lists-25026" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25088" href="../Lists/#plfa_plfa-part1-Lists-25040" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25091" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25093" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25097" href="../Lists/#plfa_plfa-part1-Lists-25026" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25099" href="../Lists/#plfa_plfa-part1-Lists-25043" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25101" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25105" href="../Lists/#plfa_plfa-part1-Lists-25008" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25108" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25111" href="../Lists/#plfa_plfa-part1-Lists-25111" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25114" href="../Lists/#plfa_plfa-part1-Lists-25114" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25118" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25120" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25122" href="../Lists/#plfa_plfa-part1-Lists-21846" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25125" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25127" href="../Lists/#plfa_plfa-part1-Lists-25114" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25131" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a>
  <a id="plfa_plfa-part1-Lists-25135" href="../Lists/#plfa_plfa-part1-Lists-25008" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25138" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25139" href="../Lists/#plfa_plfa-part1-Lists-25139" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25141" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25143" href="../Lists/#plfa_plfa-part1-Lists-25143" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25145" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25147" href="../Lists/#plfa_plfa-part1-Lists-25147" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25150" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25151" href="../Lists/#plfa_plfa-part1-Lists-25151" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25154" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25156" href="../Lists/#plfa_plfa-part1-Lists-25156" class="Bound">Pxs++ys</a><a id="plfa_plfa-part1-Lists-25163" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25165" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-25170" href="../Lists/#plfa_plfa-part1-Lists-25008" class="Function">to</a> <a id="plfa_plfa-part1-Lists-25173" href="../Lists/#plfa_plfa-part1-Lists-25143" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25176" href="../Lists/#plfa_plfa-part1-Lists-25147" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25179" href="../Lists/#plfa_plfa-part1-Lists-25156" class="Bound">Pxs++ys</a>
  <a id="plfa_plfa-part1-Lists-25189" class="Symbol">...</a> <a id="plfa_plfa-part1-Lists-25193" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-25195" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25197" href="../Lists/#plfa_plfa-part1-Lists-25197" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25201" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25203" href="../Lists/#plfa_plfa-part1-Lists-25203" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25207" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25209" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25211" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25213" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25216" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25218" href="../Lists/#plfa_plfa-part1-Lists-25197" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25222" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25224" href="../Lists/#plfa_plfa-part1-Lists-25203" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25228" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a>

  <a id="plfa_plfa-part1-Lists-25233" href="../Lists/#plfa_plfa-part1-Lists-25233" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25238" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25240" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-25242" class="Symbol">{</a> <a id="plfa_plfa-part1-Lists-25244" href="../Lists/#plfa_plfa-part1-Lists-25244" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25246" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25248" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25251" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25253" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-25254" href="../Lists/#plfa_plfa-part1-Lists-25254" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25256" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25258" href="../Lists/#plfa_plfa-part1-Lists-25244" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-25260" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25262" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-25265" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-25267" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25268" href="../Lists/#plfa_plfa-part1-Lists-25268" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25271" href="../Lists/#plfa_plfa-part1-Lists-25271" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25274" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-25276" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-25281" href="../Lists/#plfa_plfa-part1-Lists-25244" class="Bound">A</a><a id="plfa_plfa-part1-Lists-25282" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25284" class="Symbol">→</a>
    <a id="plfa_plfa-part1-Lists-25290" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25294" href="../Lists/#plfa_plfa-part1-Lists-25254" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25296" href="../Lists/#plfa_plfa-part1-Lists-25268" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25299" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Product.html#1176" class="Function Operator">×</a> <a id="plfa_plfa-part1-Lists-25301" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25305" href="../Lists/#plfa_plfa-part1-Lists-25254" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25307" href="../Lists/#plfa_plfa-part1-Lists-25271" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25310" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-25312" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-25316" href="../Lists/#plfa_plfa-part1-Lists-25254" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-25318" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25319" href="../Lists/#plfa_plfa-part1-Lists-25268" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25322" href="../Lists/#plfa_plfa-part1-Lists-3451" class="Function Operator">++</a> <a id="plfa_plfa-part1-Lists-25325" href="../Lists/#plfa_plfa-part1-Lists-25271" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-25327" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-25331" href="../Lists/#plfa_plfa-part1-Lists-25233" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25336" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25339" href="../Lists/#plfa_plfa-part1-Lists-25339" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25342" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25344" href="../Lists/#plfa_plfa-part1-Lists-21846" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-25347" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25349" href="../Lists/#plfa_plfa-part1-Lists-25349" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25353" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25355" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-25357" href="../Lists/#plfa_plfa-part1-Lists-25349" class="Bound">Pys</a>
  <a id="plfa_plfa-part1-Lists-25363" href="../Lists/#plfa_plfa-part1-Lists-25233" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25368" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-25369" href="../Lists/#plfa_plfa-part1-Lists-25369" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-25371" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25373" href="../Lists/#plfa_plfa-part1-Lists-25373" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-25375" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-25377" href="../Lists/#plfa_plfa-part1-Lists-25377" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25380" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25382" href="../Lists/#plfa_plfa-part1-Lists-25382" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25385" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25387" href="../Lists/#plfa_plfa-part1-Lists-25387" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25391" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25393" href="../Lists/#plfa_plfa-part1-Lists-25393" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25397" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a> <a id="plfa_plfa-part1-Lists-25399" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-25402" href="../Lists/#plfa_plfa-part1-Lists-25382" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-25405" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-25407" href="../Lists/#plfa_plfa-part1-Lists-25233" class="Function">from</a> <a id="plfa_plfa-part1-Lists-25412" href="../Lists/#plfa_plfa-part1-Lists-25373" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-25415" href="../Lists/#plfa_plfa-part1-Lists-25377" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-25418" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟨</a> <a id="plfa_plfa-part1-Lists-25420" href="../Lists/#plfa_plfa-part1-Lists-25387" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-25424" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-25426" href="../Lists/#plfa_plfa-part1-Lists-25393" class="Bound">Pys</a> <a id="plfa_plfa-part1-Lists-25430" href="../Lists/#plfa_plfa-part1-Lists-840" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="exercise-any---recommended">Exercise <code>Any-++-⇔</code> (recommended)</h4><p>Prove a result similar to <code>All-++-⇔</code>, but with <code>Any</code> in place of <code>All</code>, and a suitable replacement for <code>_×_</code>. As a consequence, demonstrate an equivalence relating <code>_∈_</code> and <code>_++_</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25669" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-all---stretch">Exercise <code>All-++-≃</code> (stretch)</h4><p>Show that the equivalence <code>All-++-⇔</code> can be extended to an isomorphism.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-25814" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-anyall-recommended">Exercise <code>¬Any⇔All¬</code> (recommended)</h4><p>Show that <code>Any</code> and <code>All</code> satisfy a version of De Morgan’s Law:</p><pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre><p>(Can you see why it is important that here <code>_∘_</code> is generalised to arbitrary levels, as described in the section on <a href="../Equality/#unipoly">universe polymorphism</a>?)</p><p>Do we also have the following?</p><pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre><p>If so, prove; if not, explain why.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26266" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-anyall-stretch">Exercise <code>¬Any≃All¬</code> (stretch)</h4><p>Show that the equivalence <code>¬Any⇔All¬</code> can be extended to an isomorphism. You will need to use extensionality.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26450" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-all--practice">Exercise <code>All-∀</code> (practice)</h4><p>Show that <code>All P xs</code> is isomorphic to <code>∀ x → x ∈ xs → P x</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26581" class="Comment">-- You code goes here</a>
</pre><h4 id="exercise-any--practice">Exercise <code>Any-∃</code> (practice)</h4><p>Show that <code>Any P xs</code> is isomorphic to <code>∃[ x ] (x ∈ xs × P x)</code>.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-26715" class="Comment">-- You code goes here</a>
</pre><h2 id="decidability-of-all">Decidability of All</h2>If we consider a predicate as a function that yields a boolean, it is easy to define an analogue of <code>All</code>, which returns true if a given predicate returns true for every element of a list:<pre class="Agda"><a id="plfa_plfa-part1-Lists-all"></a><a id="plfa_plfa-part1-Lists-26964" href="../Lists/#plfa_plfa-part1-Lists-26964" class="Function">all</a> <a id="plfa_plfa-part1-Lists-26968" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26970" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-26972" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-26973" href="../Lists/#plfa_plfa-part1-Lists-26973" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26975" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-26977" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-26980" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-26982" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26984" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-26985" href="../Lists/#plfa_plfa-part1-Lists-26973" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-26987" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26989" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="plfa_plfa-part1-Lists-26993" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-26995" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-26997" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-27002" href="../Lists/#plfa_plfa-part1-Lists-26973" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27004" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27006" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
<a id="plfa_plfa-part1-Lists-27011" href="../Lists/#plfa_plfa-part1-Lists-26964" class="Function">all</a> <a id="plfa_plfa-part1-Lists-27015" href="../Lists/#plfa_plfa-part1-Lists-27015" class="Bound">p</a>  <a id="plfa_plfa-part1-Lists-27018" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27021" href="../Lists/#plfa_plfa-part1-Lists-15420" class="Function">foldr</a> <a id="plfa_plfa-part1-Lists-27027" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.Bool.Base.html#995" class="Function Operator">_∧_</a> <a id="plfa_plfa-part1-Lists-27031" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a> <a id="plfa_plfa-part1-Lists-27036" href="https://agda.github.io/agda-stdlib/v1.7.2/Function.Base.html#1040" class="Function Operator">∘</a> <a id="plfa_plfa-part1-Lists-27038" href="../Lists/#plfa_plfa-part1-Lists-12963" class="Function">map</a> <a id="plfa_plfa-part1-Lists-27042" href="../Lists/#plfa_plfa-part1-Lists-27015" class="Bound">p</a>
</pre><p>The function can be written in a particularly compact style by using the higher-order functions <code>map</code> and <code>foldr</code>.</p>As one would hope, if we replace booleans by decidables there is again an analogue of <code>All</code>. First, return to the notion of a predicate <code>P</code> as a function of type <code>A → Set</code>, taking a value <code>x</code> of type <code>A</code> into evidence <code>P x</code> that a property holds for <code>x</code>. Say that a predicate <code>P</code> is <em>decidable</em> if we have a function that for a given <code>x</code> can decide <code>P x</code>:<pre class="Agda"><a id="plfa_plfa-part1-Lists-Decidable"></a><a id="plfa_plfa-part1-Lists-27530" href="../Lists/#plfa_plfa-part1-Lists-27530" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27540" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27542" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27544" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27545" href="../Lists/#plfa_plfa-part1-Lists-27545" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27547" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27549" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27552" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27554" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27556" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27557" href="../Lists/#plfa_plfa-part1-Lists-27545" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27559" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27561" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27564" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27566" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27568" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="plfa_plfa-part1-Lists-27572" href="../Lists/#plfa_plfa-part1-Lists-27530" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27582" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27583" href="../Lists/#plfa_plfa-part1-Lists-27583" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27584" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27586" href="../Lists/#plfa_plfa-part1-Lists-27586" class="Bound">P</a>  <a id="plfa_plfa-part1-Lists-27589" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27592" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27594" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27595" href="../Lists/#plfa_plfa-part1-Lists-27595" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27597" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27599" href="../Lists/#plfa_plfa-part1-Lists-27583" class="Bound">A</a><a id="plfa_plfa-part1-Lists-27600" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27602" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27604" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1520" class="Record">Dec</a> <a id="plfa_plfa-part1-Lists-27608" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27609" href="../Lists/#plfa_plfa-part1-Lists-27586" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27611" href="../Lists/#plfa_plfa-part1-Lists-27595" class="Bound">x</a><a id="plfa_plfa-part1-Lists-27612" class="Symbol">)</a>
</pre>Then if predicate <code>P</code> is decidable, it is also decidable whether every element of a list satisfies the predicate:<pre class="Agda"><a id="plfa_plfa-part1-Lists-All?"></a><a id="plfa_plfa-part1-Lists-27740" href="../Lists/#plfa_plfa-part1-Lists-27740" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27745" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27747" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-27749" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27750" href="../Lists/#plfa_plfa-part1-Lists-27750" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27752" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27754" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27757" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27759" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-27760" href="../Lists/#plfa_plfa-part1-Lists-27760" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27762" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-27764" href="../Lists/#plfa_plfa-part1-Lists-27750" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-27766" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27768" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-27771" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-27773" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27775" href="../Lists/#plfa_plfa-part1-Lists-27530" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27785" href="../Lists/#plfa_plfa-part1-Lists-27760" class="Bound">P</a> <a id="plfa_plfa-part1-Lists-27787" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-27789" href="../Lists/#plfa_plfa-part1-Lists-27530" class="Function">Decidable</a> <a id="plfa_plfa-part1-Lists-27799" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27800" href="../Lists/#plfa_plfa-part1-Lists-21795" class="Datatype">All</a> <a id="plfa_plfa-part1-Lists-27804" href="../Lists/#plfa_plfa-part1-Lists-27760" class="Bound">P</a><a id="plfa_plfa-part1-Lists-27805" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-27807" href="../Lists/#plfa_plfa-part1-Lists-27740" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27812" href="../Lists/#plfa_plfa-part1-Lists-27812" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27815" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>                                 <a id="plfa_plfa-part1-Lists-27850" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27853" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-27857" href="../Lists/#plfa_plfa-part1-Lists-21846" class="InductiveConstructor">[]</a>
<a id="plfa_plfa-part1-Lists-27860" href="../Lists/#plfa_plfa-part1-Lists-27740" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27865" href="../Lists/#plfa_plfa-part1-Lists-27865" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27868" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27869" href="../Lists/#plfa_plfa-part1-Lists-27869" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-27871" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27873" href="../Lists/#plfa_plfa-part1-Lists-27873" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-27875" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-27877" class="Keyword">with</a> <a id="plfa_plfa-part1-Lists-27882" href="../Lists/#plfa_plfa-part1-Lists-27865" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27885" href="../Lists/#plfa_plfa-part1-Lists-27869" class="Bound">x</a>   <a id="plfa_plfa-part1-Lists-27889" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27891" href="../Lists/#plfa_plfa-part1-Lists-27740" class="Function">All?</a> <a id="plfa_plfa-part1-Lists-27896" href="../Lists/#plfa_plfa-part1-Lists-27865" class="Bound">P?</a> <a id="plfa_plfa-part1-Lists-27899" href="../Lists/#plfa_plfa-part1-Lists-27873" class="Bound">xs</a>
<a id="plfa_plfa-part1-Lists-27902" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-27922" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27924" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-27928" href="../Lists/#plfa_plfa-part1-Lists-27928" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-27931" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27933" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-27937" href="../Lists/#plfa_plfa-part1-Lists-27937" class="Bound">Pxs</a>     <a id="plfa_plfa-part1-Lists-27945" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-27948" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="plfa_plfa-part1-Lists-27952" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-27953" href="../Lists/#plfa_plfa-part1-Lists-27928" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-27956" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-27958" href="../Lists/#plfa_plfa-part1-Lists-27937" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-27961" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-27963" class="Symbol">...</a>                 <a id="plfa_plfa-part1-Lists-27983" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27985" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-27988" href="../Lists/#plfa_plfa-part1-Lists-27988" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-27992" class="Symbol">|</a> <a id="plfa_plfa-part1-Lists-27994" class="Symbol">_</a>           <a id="plfa_plfa-part1-Lists-28006" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28009" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-28012" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-28015" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28016" href="../Lists/#plfa_plfa-part1-Lists-28016" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28019" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28021" href="../Lists/#plfa_plfa-part1-Lists-28021" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-28024" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28026" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28028" href="../Lists/#plfa_plfa-part1-Lists-27988" class="Bound">¬Px</a> <a id="plfa_plfa-part1-Lists-28032" href="../Lists/#plfa_plfa-part1-Lists-28016" class="Bound">Px</a>   <a id="plfa_plfa-part1-Lists-28037" class="Symbol">}</a>
<a id="plfa_plfa-part1-Lists-28039" class="CatchallClause Symbol">...</a><a id="plfa_plfa-part1-Lists-28042" class="CatchallClause">                 </a><a id="plfa_plfa-part1-Lists-28059" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-28060" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28061" class="CatchallClause Symbol">_</a><a id="plfa_plfa-part1-Lists-28062" class="CatchallClause">      </a><a id="plfa_plfa-part1-Lists-28068" class="CatchallClause Symbol">|</a><a id="plfa_plfa-part1-Lists-28069" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28070" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1694" class="CatchallClause InductiveConstructor">no</a><a id="plfa_plfa-part1-Lists-28072" class="CatchallClause"> </a><a id="plfa_plfa-part1-Lists-28073" href="../Lists/#plfa_plfa-part1-Lists-28073" class="CatchallClause Bound">¬Pxs</a>     <a id="plfa_plfa-part1-Lists-28082" class="Symbol">=</a>  <a id="plfa_plfa-part1-Lists-28085" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="plfa_plfa-part1-Lists-28088" class="Symbol">λ{</a> <a id="plfa_plfa-part1-Lists-28091" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28092" href="../Lists/#plfa_plfa-part1-Lists-28092" class="Bound">Px</a> <a id="plfa_plfa-part1-Lists-28095" href="../Lists/#plfa_plfa-part1-Lists-21863" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-28097" href="../Lists/#plfa_plfa-part1-Lists-28097" class="Bound">Pxs</a><a id="plfa_plfa-part1-Lists-28100" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28102" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28104" href="../Lists/#plfa_plfa-part1-Lists-28073" class="Bound">¬Pxs</a> <a id="plfa_plfa-part1-Lists-28109" href="../Lists/#plfa_plfa-part1-Lists-28097" class="Bound">Pxs</a> <a id="plfa_plfa-part1-Lists-28113" class="Symbol">}</a>
</pre><p>If the list is empty, then trivially <code>P</code> holds for every element of the list. Otherwise, the structure of the proof is similar to that showing that the conjunction of two decidable propositions is itself decidable, using <code>_∷_</code> rather than <code>⟨_,_⟩</code> to combine the evidence for the head and tail of the list.</p><h4 id="exercise-any-stretch">Exercise <code>Any?</code> (stretch)</h4><p>Just as <code>All</code> has analogues <code>all</code> and <code>All?</code> which determine whether a predicate holds for every element of a list, so does <code>Any</code> have analogues <code>any</code> and <code>Any?</code> which determine whether a predicate holds for some element of a list. Give their definitions.</p><pre class="Agda"><a id="plfa_plfa-part1-Lists-28726" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-split-stretch">Exercise <code>split</code> (stretch)</h4>The relation <code>merge</code> holds when two lists merge to give a third list.<pre class="Agda"><a id="plfa_plfa-part1-Lists-28866" class="Keyword">data</a> <a id="plfa_plfa-part1-Lists-merge"></a><a id="plfa_plfa-part1-Lists-28871" href="../Lists/#plfa_plfa-part1-Lists-28871" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-28877" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-28878" href="../Lists/#plfa_plfa-part1-Lists-28878" class="Bound">A</a> <a id="plfa_plfa-part1-Lists-28880" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28882" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a><a id="plfa_plfa-part1-Lists-28885" class="Symbol">}</a> <a id="plfa_plfa-part1-Lists-28887" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28889" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-28890" href="../Lists/#plfa_plfa-part1-Lists-28890" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28893" href="../Lists/#plfa_plfa-part1-Lists-28893" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-28896" href="../Lists/#plfa_plfa-part1-Lists-28896" class="Bound">zs</a> <a id="plfa_plfa-part1-Lists-28899" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28901" href="../Lists/#plfa_plfa-part1-Lists-1031" class="Datatype">List</a> <a id="plfa_plfa-part1-Lists-28906" href="../Lists/#plfa_plfa-part1-Lists-28878" class="Bound">A</a><a id="plfa_plfa-part1-Lists-28907" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-28909" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-28911" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Primitive.html#320" class="Primitive">Set</a> <a id="plfa_plfa-part1-Lists-28915" class="Keyword">where</a>

  <a id="plfa_plfa-part1-Lists-merge.[]"></a><a id="plfa_plfa-part1-Lists-28924" href="../Lists/#plfa_plfa-part1-Lists-28924" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-28927" class="Symbol">:</a>
      <a id="plfa_plfa-part1-Lists-28935" class="Comment">--------------</a>
      <a id="plfa_plfa-part1-Lists-28956" href="../Lists/#plfa_plfa-part1-Lists-28871" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-28962" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-28965" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a> <a id="plfa_plfa-part1-Lists-28968" href="../Lists/#plfa_plfa-part1-Lists-1060" class="InductiveConstructor">[]</a>

  <a id="plfa_plfa-part1-Lists-merge.left-∷"></a><a id="plfa_plfa-part1-Lists-28974" href="../Lists/#plfa_plfa-part1-Lists-28974" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-28981" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-28983" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-28985" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-28986" href="../Lists/#plfa_plfa-part1-Lists-28986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-28988" href="../Lists/#plfa_plfa-part1-Lists-28988" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-28991" href="../Lists/#plfa_plfa-part1-Lists-28991" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-28994" href="../Lists/#plfa_plfa-part1-Lists-28994" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-28996" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-29002" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29004" href="../Lists/#plfa_plfa-part1-Lists-28871" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29010" href="../Lists/#plfa_plfa-part1-Lists-28988" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29013" href="../Lists/#plfa_plfa-part1-Lists-28991" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29016" href="../Lists/#plfa_plfa-part1-Lists-28994" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-29025" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-29056" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29058" href="../Lists/#plfa_plfa-part1-Lists-28871" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29064" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29065" href="../Lists/#plfa_plfa-part1-Lists-28986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29067" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29069" href="../Lists/#plfa_plfa-part1-Lists-28988" class="Bound">xs</a><a id="plfa_plfa-part1-Lists-29071" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29073" href="../Lists/#plfa_plfa-part1-Lists-28991" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29076" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29077" href="../Lists/#plfa_plfa-part1-Lists-28986" class="Bound">x</a> <a id="plfa_plfa-part1-Lists-29079" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29081" href="../Lists/#plfa_plfa-part1-Lists-28994" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29083" class="Symbol">)</a>

  <a id="plfa_plfa-part1-Lists-merge.right-∷"></a><a id="plfa_plfa-part1-Lists-29088" href="../Lists/#plfa_plfa-part1-Lists-29088" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29096" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29098" class="Symbol">∀</a> <a id="plfa_plfa-part1-Lists-29100" class="Symbol">{</a><a id="plfa_plfa-part1-Lists-29101" href="../Lists/#plfa_plfa-part1-Lists-29101" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29103" href="../Lists/#plfa_plfa-part1-Lists-29103" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29106" href="../Lists/#plfa_plfa-part1-Lists-29106" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29109" href="../Lists/#plfa_plfa-part1-Lists-29109" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29111" class="Symbol">}</a>
    <a id="plfa_plfa-part1-Lists-29117" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29119" href="../Lists/#plfa_plfa-part1-Lists-28871" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29125" href="../Lists/#plfa_plfa-part1-Lists-29103" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29128" href="../Lists/#plfa_plfa-part1-Lists-29106" class="Bound">ys</a> <a id="plfa_plfa-part1-Lists-29131" href="../Lists/#plfa_plfa-part1-Lists-29109" class="Bound">zs</a>
      <a id="plfa_plfa-part1-Lists-29140" class="Comment">--------------------------</a>
    <a id="plfa_plfa-part1-Lists-29171" class="Symbol">→</a> <a id="plfa_plfa-part1-Lists-29173" href="../Lists/#plfa_plfa-part1-Lists-28871" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29179" href="../Lists/#plfa_plfa-part1-Lists-29103" class="Bound">xs</a> <a id="plfa_plfa-part1-Lists-29182" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29183" href="../Lists/#plfa_plfa-part1-Lists-29101" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29185" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29187" href="../Lists/#plfa_plfa-part1-Lists-29106" class="Bound">ys</a><a id="plfa_plfa-part1-Lists-29189" class="Symbol">)</a> <a id="plfa_plfa-part1-Lists-29191" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29192" href="../Lists/#plfa_plfa-part1-Lists-29101" class="Bound">y</a> <a id="plfa_plfa-part1-Lists-29194" href="../Lists/#plfa_plfa-part1-Lists-1075" class="InductiveConstructor Operator">∷</a> <a id="plfa_plfa-part1-Lists-29196" href="../Lists/#plfa_plfa-part1-Lists-29109" class="Bound">zs</a><a id="plfa_plfa-part1-Lists-29198" class="Symbol">)</a>
</pre>For example,<pre class="Agda"><a id="plfa_plfa-part1-Lists-29226" href="../Lists/#plfa_plfa-part1-Lists-29226" class="Function">_</a> <a id="plfa_plfa-part1-Lists-29228" class="Symbol">:</a> <a id="plfa_plfa-part1-Lists-29230" href="../Lists/#plfa_plfa-part1-Lists-28871" class="Datatype">merge</a> <a id="plfa_plfa-part1-Lists-29236" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29238" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29240" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29242" class="Number">4</a> <a id="plfa_plfa-part1-Lists-29244" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-29246" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29248" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29250" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29252" class="Number">3</a> <a id="plfa_plfa-part1-Lists-29254" href="../Lists/#plfa_plfa-part1-Lists-2830" class="InductiveConstructor Operator">]</a> <a id="plfa_plfa-part1-Lists-29256" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">[</a> <a id="plfa_plfa-part1-Lists-29258" class="Number">1</a> <a id="plfa_plfa-part1-Lists-29260" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29262" class="Number">2</a> <a id="plfa_plfa-part1-Lists-29264" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29266" class="Number">3</a> <a id="plfa_plfa-part1-Lists-29268" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">,</a> <a id="plfa_plfa-part1-Lists-29270" class="Number">4</a> <a id="plfa_plfa-part1-Lists-29272" href="../Lists/#plfa_plfa-part1-Lists-2900" class="InductiveConstructor Operator">]</a>
<a id="plfa_plfa-part1-Lists-29274" class="Symbol">_</a> <a id="plfa_plfa-part1-Lists-29276" class="Symbol">=</a> <a id="plfa_plfa-part1-Lists-29278" href="../Lists/#plfa_plfa-part1-Lists-28974" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29285" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29286" href="../Lists/#plfa_plfa-part1-Lists-29088" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29294" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29295" href="../Lists/#plfa_plfa-part1-Lists-29088" class="InductiveConstructor">right-∷</a> <a id="plfa_plfa-part1-Lists-29303" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-29304" href="../Lists/#plfa_plfa-part1-Lists-28974" class="InductiveConstructor">left-∷</a> <a id="plfa_plfa-part1-Lists-29311" href="../Lists/#plfa_plfa-part1-Lists-28924" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-29313" class="Symbol">)))</a>

</pre><p>Given a decidable predicate and a list, we can split the list into two lists that merge to give the original list, where all elements of one list satisfy the predicate, and all elements of the other do not satisfy the predicate.</p><p>Define the following variant of the traditional <code>filter</code> function on lists, which given a decidable predicate and a list returns a list of elements that satisfy the predicate and a list of elements that don’t, with their corresponding proofs.</p><pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre><pre class="Agda"><a id="plfa_plfa-part1-Lists-29949" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard Library</h2>Definitions similar to those in this chapter can be found in the standard library:<pre class="Agda"><a id="plfa_plfa-part1-Lists-30089" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30096" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.html" class="Module">Data.List</a> <a id="plfa_plfa-part1-Lists-30106" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30112" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30113" href="https://agda.github.io/agda-stdlib/v1.7.2/Agda.Builtin.List.html#130" class="Datatype">List</a><a id="plfa_plfa-part1-Lists-30117" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30119" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Base.html#1819" class="Function Operator">_++_</a><a id="plfa_plfa-part1-Lists-30123" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30125" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Base.html#4873" class="Function">length</a><a id="plfa_plfa-part1-Lists-30131" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30133" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Base.html#9826" class="Function">reverse</a><a id="plfa_plfa-part1-Lists-30140" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30142" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Base.html#1553" class="Function">map</a><a id="plfa_plfa-part1-Lists-30145" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30147" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Base.html#4201" class="Function">foldr</a><a id="plfa_plfa-part1-Lists-30152" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30154" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Base.html#6282" class="Function">downFrom</a><a id="plfa_plfa-part1-Lists-30162" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30164" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30171" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="plfa_plfa-part1-Lists-30200" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30206" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30207" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Relation.Unary.All.html#1453" class="Datatype">All</a><a id="plfa_plfa-part1-Lists-30210" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30212" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Relation.Unary.All.html#1516" class="InductiveConstructor">[]</a><a id="plfa_plfa-part1-Lists-30214" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30216" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Relation.Unary.All.html#1533" class="InductiveConstructor Operator">_∷_</a><a id="plfa_plfa-part1-Lists-30219" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30221" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30228" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="plfa_plfa-part1-Lists-30257" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30263" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30264" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Relation.Unary.Any.html#1165" class="Datatype">Any</a><a id="plfa_plfa-part1-Lists-30267" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30269" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Relation.Unary.Any.html#1228" class="InductiveConstructor">here</a><a id="plfa_plfa-part1-Lists-30273" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30275" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Relation.Unary.Any.html#1281" class="InductiveConstructor">there</a><a id="plfa_plfa-part1-Lists-30280" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30282" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30289" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="plfa_plfa-part1-Lists-30324" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30330" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30331" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Membership.Setoid.html#896" class="Function Operator">_∈_</a><a id="plfa_plfa-part1-Lists-30334" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30336" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30343" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="plfa_plfa-part1-Lists-30366" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30372" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30373" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Properties.html#34565" class="Function">reverse-++-commute</a><a id="plfa_plfa-part1-Lists-30391" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30393" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Properties.html#3777" class="Function">map-compose</a><a id="plfa_plfa-part1-Lists-30404" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30406" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Properties.html#3094" class="Function">map-++-commute</a><a id="plfa_plfa-part1-Lists-30420" class="Symbol">;</a> <a id="plfa_plfa-part1-Lists-30422" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Properties.html#16289" class="Function">foldr-++</a><a id="plfa_plfa-part1-Lists-30430" class="Symbol">)</a>
  <a id="plfa_plfa-part1-Lists-30434" class="Keyword">renaming</a> <a id="plfa_plfa-part1-Lists-30443" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30444" href="https://agda.github.io/agda-stdlib/v1.7.2/Data.List.Properties.html#40465" class="Function">mapIsFold</a> <a id="plfa_plfa-part1-Lists-30454" class="Symbol">to</a> <a id="plfa_plfa-part1-Lists-30457" class="Function">map-is-foldr</a><a id="plfa_plfa-part1-Lists-30469" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30471" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30478" href="https://agda.github.io/agda-stdlib/v1.7.2/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="plfa_plfa-part1-Lists-30497" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30503" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30504" href="https://agda.github.io/agda-stdlib/v1.7.2/Algebra.Structures.html#2810" class="Record">IsMonoid</a><a id="plfa_plfa-part1-Lists-30512" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30514" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30521" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="plfa_plfa-part1-Lists-30536" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30542" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30543" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Unary.html#3545" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-30552" class="Symbol">)</a>
<a id="plfa_plfa-part1-Lists-30554" class="Keyword">import</a> <a id="plfa_plfa-part1-Lists-30561" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="plfa_plfa-part1-Lists-30577" class="Keyword">using</a> <a id="plfa_plfa-part1-Lists-30583" class="Symbol">(</a><a id="plfa_plfa-part1-Lists-30584" href="https://agda.github.io/agda-stdlib/v1.7.2/Relation.Binary.Definitions.html#4584" class="Function">Decidable</a><a id="plfa_plfa-part1-Lists-30593" class="Symbol">)</a>
</pre><p>The standard library version of <code>IsMonoid</code> differs from the one given here, in that it is also parameterised on an equivalence relation.</p><p>Both <code>Relation.Unary</code> and <code>Relation.Binary</code> define a version of <code>Decidable</code>, one for unary relations (as used in this chapter where <code>P</code> ranges over unary predicates) and one for binary relations (as used earlier, where <code>_≤_</code> ranges over a binary relation).</p><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><pre><code>∷  U+2237  PROPORTION  (\::)
⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
∈  U+2208  ELEMENT OF  (\in)
∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)</code></pre></div><nav class="pager" aria-label="Chapter"><ul class="pagination"><li><a class="pagelink" href="../Decidable/">Prev</a></li><li class="separator">•</li><li><a class="pagelink" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/part1/Lists.lagda.md">Source</a></li><li class="separator">•</li><li><a class="pagelink" href="../Lambda/">Next</a></li><li class="separator">•</li></ul></nav></article></div></main><footer class="site-footer h-card" aria-label="Site"><data class="u-url" href="../"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk"><i class="far fa-envelope"></i>  wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wadler" title="wadler"><i class="fab fa-github"></i>  wadler</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:me@wen.works"><i class="far fa-envelope"></i>  me@wen.works</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><i class="fab fa-github"></i>  wenkokke</a></li><li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><i class="fab fa-twitter"></i>  wenkokke</a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu"><i class="far fa-envelope"></i>  jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a rel="me" href="https://github.com/jsiek" title="jsiek"><i class="fab fa-github"></i>  jsiek</a></li><li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><i class="fab fa-twitter"></i>  jeremysiek</a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer></body></html>